(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [760],
  {
    42: function (t, e, i) {
      "use strict";
      var n = i(5786),
        r = { "text/plain": "Text", "text/html": "Url", default: "Text" };
      t.exports = function (t, e) {
        var i,
          o,
          s,
          a,
          l,
          u,
          c,
          h,
          d = !1;
        e || (e = {}), (s = e.debug || !1);
        try {
          if (
            ((l = n()),
            (u = document.createRange()),
            (c = document.getSelection()),
            ((h = document.createElement("span")).textContent = t),
            (h.ariaHidden = "true"),
            (h.style.all = "unset"),
            (h.style.position = "fixed"),
            (h.style.top = 0),
            (h.style.clip = "rect(0, 0, 0, 0)"),
            (h.style.whiteSpace = "pre"),
            (h.style.webkitUserSelect = "text"),
            (h.style.MozUserSelect = "text"),
            (h.style.msUserSelect = "text"),
            (h.style.userSelect = "text"),
            h.addEventListener("copy", function (i) {
              if ((i.stopPropagation(), e.format)) {
                if ((i.preventDefault(), void 0 === i.clipboardData)) {
                  s && console.warn("unable to use e.clipboardData"),
                    s && console.warn("trying IE specific stuff"),
                    window.clipboardData.clearData();
                  var n = r[e.format] || r.default;
                  window.clipboardData.setData(n, t);
                } else
                  i.clipboardData.clearData(),
                    i.clipboardData.setData(e.format, t);
              }
              e.onCopy && (i.preventDefault(), e.onCopy(i.clipboardData));
            }),
            document.body.appendChild(h),
            u.selectNodeContents(h),
            c.addRange(u),
            !document.execCommand("copy"))
          )
            throw Error("copy command was unsuccessful");
          d = !0;
        } catch (n) {
          s && console.error("unable to copy using execCommand: ", n),
            s && console.warn("trying IE specific stuff");
          try {
            window.clipboardData.setData(e.format || "text", t),
              e.onCopy && e.onCopy(window.clipboardData),
              (d = !0);
          } catch (n) {
            s && console.error("unable to copy using clipboardData: ", n),
              s && console.error("falling back to prompt"),
              (i =
                "message" in e
                  ? e.message
                  : "Copy to clipboard: #{key}, Enter"),
              (o =
                (/mac os x/i.test(navigator.userAgent) ? "âŒ˜" : "Ctrl") + "+C"),
              (a = i.replace(/#{\s*key\s*}/g, o)),
              window.prompt(a, t);
          }
        } finally {
          c &&
            ("function" == typeof c.removeRange
              ? c.removeRange(u)
              : c.removeAllRanges()),
            h && document.body.removeChild(h),
            l();
        }
        return d;
      };
    },
    6648: function (t, e, i) {
      "use strict";
      i.d(e, {
        default: function () {
          return r.a;
        },
      });
      var n = i(5601),
        r = i.n(n);
    },
    8173: function (t, e, i) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "Image", {
          enumerable: !0,
          get: function () {
            return x;
          },
        });
      let n = i(9920),
        r = i(1452),
        o = i(7437),
        s = r._(i(2265)),
        a = n._(i(4887)),
        l = n._(i(8321)),
        u = i(497),
        c = i(7103),
        h = i(3938);
      i(2301);
      let d = i(291),
        p = n._(i(1241)),
        f = {
          deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
          imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
          path: "/_next/image",
          loader: "default",
          dangerouslyAllowSVG: !1,
          unoptimized: !1,
        };
      function m(t, e, i, n, r, o, s) {
        let a = null == t ? void 0 : t.src;
        t &&
          t["data-loaded-src"] !== a &&
          ((t["data-loaded-src"] = a),
          ("decode" in t ? t.decode() : Promise.resolve())
            .catch(() => {})
            .then(() => {
              if (t.parentElement && t.isConnected) {
                if (("empty" !== e && r(!0), null == i ? void 0 : i.current)) {
                  let e = new Event("load");
                  Object.defineProperty(e, "target", {
                    writable: !1,
                    value: t,
                  });
                  let n = !1,
                    r = !1;
                  i.current({
                    ...e,
                    nativeEvent: e,
                    currentTarget: t,
                    target: t,
                    isDefaultPrevented: () => n,
                    isPropagationStopped: () => r,
                    persist: () => {},
                    preventDefault: () => {
                      (n = !0), e.preventDefault();
                    },
                    stopPropagation: () => {
                      (r = !0), e.stopPropagation();
                    },
                  });
                }
                (null == n ? void 0 : n.current) && n.current(t);
              }
            }));
      }
      function v(t) {
        return s.use ? { fetchPriority: t } : { fetchpriority: t };
      }
      "undefined" == typeof window && (globalThis.__NEXT_IMAGE_IMPORTED = !0);
      let y = (0, s.forwardRef)((t, e) => {
        let {
          src: i,
          srcSet: n,
          sizes: r,
          height: a,
          width: l,
          decoding: u,
          className: c,
          style: h,
          fetchPriority: d,
          placeholder: p,
          loading: f,
          unoptimized: y,
          fill: g,
          onLoadRef: x,
          onLoadingCompleteRef: w,
          setBlurComplete: b,
          setShowAltText: S,
          sizesInput: P,
          onLoad: T,
          onError: A,
          ...E
        } = t;
        return (0, o.jsx)("img", {
          ...E,
          ...v(d),
          loading: f,
          width: l,
          height: a,
          decoding: u,
          "data-nimg": g ? "fill" : "1",
          className: c,
          style: h,
          sizes: r,
          srcSet: n,
          src: i,
          ref: (0, s.useCallback)(
            (t) => {
              e &&
                ("function" == typeof e
                  ? e(t)
                  : "object" == typeof e && (e.current = t)),
                t &&
                  (A && (t.src = t.src), t.complete && m(t, p, x, w, b, y, P));
            },
            [i, p, x, w, b, A, y, P, e]
          ),
          onLoad: (t) => {
            m(t.currentTarget, p, x, w, b, y, P);
          },
          onError: (t) => {
            S(!0), "empty" !== p && b(!0), A && A(t);
          },
        });
      });
      function g(t) {
        let { isAppRouter: e, imgAttributes: i } = t,
          n = {
            as: "image",
            imageSrcSet: i.srcSet,
            imageSizes: i.sizes,
            crossOrigin: i.crossOrigin,
            referrerPolicy: i.referrerPolicy,
            ...v(i.fetchPriority),
          };
        return e && a.default.preload
          ? (a.default.preload(i.src, n), null)
          : (0, o.jsx)(l.default, {
              children: (0, o.jsx)(
                "link",
                { rel: "preload", href: i.srcSet ? void 0 : i.src, ...n },
                "__nimg-" + i.src + i.srcSet + i.sizes
              ),
            });
      }
      let x = (0, s.forwardRef)((t, e) => {
        let i = (0, s.useContext)(d.RouterContext),
          n = (0, s.useContext)(h.ImageConfigContext),
          r = (0, s.useMemo)(() => {
            let t = f || n || c.imageConfigDefault,
              e = [...t.deviceSizes, ...t.imageSizes].sort((t, e) => t - e),
              i = t.deviceSizes.sort((t, e) => t - e);
            return { ...t, allSizes: e, deviceSizes: i };
          }, [n]),
          { onLoad: a, onLoadingComplete: l } = t,
          m = (0, s.useRef)(a);
        (0, s.useEffect)(() => {
          m.current = a;
        }, [a]);
        let v = (0, s.useRef)(l);
        (0, s.useEffect)(() => {
          v.current = l;
        }, [l]);
        let [x, w] = (0, s.useState)(!1),
          [b, S] = (0, s.useState)(!1),
          { props: P, meta: T } = (0, u.getImgProps)(t, {
            defaultLoader: p.default,
            imgConf: r,
            blurComplete: x,
            showAltText: b,
          });
        return (0, o.jsxs)(o.Fragment, {
          children: [
            (0, o.jsx)(y, {
              ...P,
              unoptimized: T.unoptimized,
              placeholder: T.placeholder,
              fill: T.fill,
              onLoadRef: m,
              onLoadingCompleteRef: v,
              setBlurComplete: w,
              setShowAltText: S,
              sizesInput: t.sizes,
              ref: e,
            }),
            T.priority
              ? (0, o.jsx)(g, { isAppRouter: !i, imgAttributes: P })
              : null,
          ],
        });
      });
      ("function" == typeof e.default ||
        ("object" == typeof e.default && null !== e.default)) &&
        void 0 === e.default.__esModule &&
        (Object.defineProperty(e.default, "__esModule", { value: !0 }),
        Object.assign(e.default, e),
        (t.exports = e.default));
    },
    2901: function (t, e, i) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "AmpStateContext", {
          enumerable: !0,
          get: function () {
            return n;
          },
        });
      let n = i(9920)._(i(2265)).default.createContext({});
    },
    687: function (t, e) {
      "use strict";
      function i(t) {
        let {
          ampFirst: e = !1,
          hybrid: i = !1,
          hasQuery: n = !1,
        } = void 0 === t ? {} : t;
        return e || (i && n);
      }
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "isInAmpMode", {
          enumerable: !0,
          get: function () {
            return i;
          },
        });
    },
    497: function (t, e, i) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "getImgProps", {
          enumerable: !0,
          get: function () {
            return a;
          },
        }),
        i(2301);
      let n = i(1564),
        r = i(7103);
      function o(t) {
        return void 0 !== t.default;
      }
      function s(t) {
        return void 0 === t
          ? t
          : "number" == typeof t
          ? Number.isFinite(t)
            ? t
            : NaN
          : "string" == typeof t && /^[0-9]+$/.test(t)
          ? parseInt(t, 10)
          : NaN;
      }
      function a(t, e) {
        var i;
        let a,
          l,
          u,
          {
            src: c,
            sizes: h,
            unoptimized: d = !1,
            priority: p = !1,
            loading: f,
            className: m,
            quality: v,
            width: y,
            height: g,
            fill: x = !1,
            style: w,
            overrideSrc: b,
            onLoad: S,
            onLoadingComplete: P,
            placeholder: T = "empty",
            blurDataURL: A,
            fetchPriority: E,
            layout: C,
            objectFit: R,
            objectPosition: k,
            lazyBoundary: V,
            lazyRoot: O,
            ...D
          } = t,
          { imgConf: M, showAltText: j, blurComplete: _, defaultLoader: L } = e,
          F = M || r.imageConfigDefault;
        if ("allSizes" in F) a = F;
        else {
          let t = [...F.deviceSizes, ...F.imageSizes].sort((t, e) => t - e),
            e = F.deviceSizes.sort((t, e) => t - e);
          a = { ...F, allSizes: t, deviceSizes: e };
        }
        if (void 0 === L)
          throw Error(
            "images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config"
          );
        let B = D.loader || L;
        delete D.loader, delete D.srcSet;
        let I = "__next_img_default" in B;
        if (I) {
          if ("custom" === a.loader)
            throw Error(
              'Image with src "' +
                c +
                '" is missing "loader" prop.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader'
            );
        } else {
          let t = B;
          B = (e) => {
            let { config: i, ...n } = e;
            return t(n);
          };
        }
        if (C) {
          "fill" === C && (x = !0);
          let t = {
            intrinsic: { maxWidth: "100%", height: "auto" },
            responsive: { width: "100%", height: "auto" },
          }[C];
          t && (w = { ...w, ...t });
          let e = { responsive: "100vw", fill: "100vw" }[C];
          e && !h && (h = e);
        }
        let $ = "",
          W = s(y),
          N = s(g);
        if ("object" == typeof (i = c) && (o(i) || void 0 !== i.src)) {
          let t = o(c) ? c.default : c;
          if (!t.src)
            throw Error(
              "An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " +
                JSON.stringify(t)
            );
          if (!t.height || !t.width)
            throw Error(
              "An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " +
                JSON.stringify(t)
            );
          if (
            ((l = t.blurWidth),
            (u = t.blurHeight),
            (A = A || t.blurDataURL),
            ($ = t.src),
            !x)
          ) {
            if (W || N) {
              if (W && !N) {
                let e = W / t.width;
                N = Math.round(t.height * e);
              } else if (!W && N) {
                let e = N / t.height;
                W = Math.round(t.width * e);
              }
            } else (W = t.width), (N = t.height);
          }
        }
        let z = !p && ("lazy" === f || void 0 === f);
        (!(c = "string" == typeof c ? c : $) ||
          c.startsWith("data:") ||
          c.startsWith("blob:")) &&
          ((d = !0), (z = !1)),
          a.unoptimized && (d = !0),
          I && c.endsWith(".svg") && !a.dangerouslyAllowSVG && (d = !0),
          p && (E = "high");
        let U = s(v),
          H = Object.assign(
            x
              ? {
                  position: "absolute",
                  height: "100%",
                  width: "100%",
                  left: 0,
                  top: 0,
                  right: 0,
                  bottom: 0,
                  objectFit: R,
                  objectPosition: k,
                }
              : {},
            j ? {} : { color: "transparent" },
            w
          ),
          X =
            _ || "empty" === T
              ? null
              : "blur" === T
              ? 'url("data:image/svg+xml;charset=utf-8,' +
                (0, n.getImageBlurSvg)({
                  widthInt: W,
                  heightInt: N,
                  blurWidth: l,
                  blurHeight: u,
                  blurDataURL: A || "",
                  objectFit: H.objectFit,
                }) +
                '")'
              : 'url("' + T + '")',
          K = X
            ? {
                backgroundSize: H.objectFit || "cover",
                backgroundPosition: H.objectPosition || "50% 50%",
                backgroundRepeat: "no-repeat",
                backgroundImage: X,
              }
            : {},
          Y = (function (t) {
            let {
              config: e,
              src: i,
              unoptimized: n,
              width: r,
              quality: o,
              sizes: s,
              loader: a,
            } = t;
            if (n) return { src: i, srcSet: void 0, sizes: void 0 };
            let { widths: l, kind: u } = (function (t, e, i) {
                let { deviceSizes: n, allSizes: r } = t;
                if (i) {
                  let t = /(^|\s)(1?\d?\d)vw/g,
                    e = [];
                  for (let n; (n = t.exec(i)); n) e.push(parseInt(n[2]));
                  if (e.length) {
                    let t = 0.01 * Math.min(...e);
                    return {
                      widths: r.filter((e) => e >= n[0] * t),
                      kind: "w",
                    };
                  }
                  return { widths: r, kind: "w" };
                }
                return "number" != typeof e
                  ? { widths: n, kind: "w" }
                  : {
                      widths: [
                        ...new Set(
                          [e, 2 * e].map(
                            (t) => r.find((e) => e >= t) || r[r.length - 1]
                          )
                        ),
                      ],
                      kind: "x",
                    };
              })(e, r, s),
              c = l.length - 1;
            return {
              sizes: s || "w" !== u ? s : "100vw",
              srcSet: l
                .map(
                  (t, n) =>
                    a({ config: e, src: i, quality: o, width: t }) +
                    " " +
                    ("w" === u ? t : n + 1) +
                    u
                )
                .join(", "),
              src: a({ config: e, src: i, quality: o, width: l[c] }),
            };
          })({
            config: a,
            src: c,
            unoptimized: d,
            width: W,
            quality: U,
            sizes: h,
            loader: B,
          });
        return {
          props: {
            ...D,
            loading: z ? "lazy" : f,
            fetchPriority: E,
            width: W,
            height: N,
            decoding: "async",
            className: m,
            style: { ...H, ...K },
            sizes: Y.sizes,
            srcSet: Y.srcSet,
            src: b || Y.src,
          },
          meta: { unoptimized: d, priority: p, placeholder: T, fill: x },
        };
      }
    },
    8321: function (t, e, i) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (function (t, e) {
          for (var i in e)
            Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
        })(e, {
          default: function () {
            return m;
          },
          defaultHead: function () {
            return h;
          },
        });
      let n = i(9920),
        r = i(1452),
        o = i(7437),
        s = r._(i(2265)),
        a = n._(i(5960)),
        l = i(2901),
        u = i(6590),
        c = i(687);
      function h(t) {
        void 0 === t && (t = !1);
        let e = [(0, o.jsx)("meta", { charSet: "utf-8" })];
        return (
          t ||
            e.push(
              (0, o.jsx)("meta", {
                name: "viewport",
                content: "width=device-width",
              })
            ),
          e
        );
      }
      function d(t, e) {
        return "string" == typeof e || "number" == typeof e
          ? t
          : e.type === s.default.Fragment
          ? t.concat(
              s.default.Children.toArray(e.props.children).reduce(
                (t, e) =>
                  "string" == typeof e || "number" == typeof e
                    ? t
                    : t.concat(e),
                []
              )
            )
          : t.concat(e);
      }
      i(2301);
      let p = ["name", "httpEquiv", "charSet", "itemProp"];
      function f(t, e) {
        let { inAmpMode: i } = e;
        return t
          .reduce(d, [])
          .reverse()
          .concat(h(i).reverse())
          .filter(
            (function () {
              let t = new Set(),
                e = new Set(),
                i = new Set(),
                n = {};
              return (r) => {
                let o = !0,
                  s = !1;
                if (
                  r.key &&
                  "number" != typeof r.key &&
                  r.key.indexOf("$") > 0
                ) {
                  s = !0;
                  let e = r.key.slice(r.key.indexOf("$") + 1);
                  t.has(e) ? (o = !1) : t.add(e);
                }
                switch (r.type) {
                  case "title":
                  case "base":
                    e.has(r.type) ? (o = !1) : e.add(r.type);
                    break;
                  case "meta":
                    for (let t = 0, e = p.length; t < e; t++) {
                      let e = p[t];
                      if (r.props.hasOwnProperty(e)) {
                        if ("charSet" === e) i.has(e) ? (o = !1) : i.add(e);
                        else {
                          let t = r.props[e],
                            i = n[e] || new Set();
                          ("name" !== e || !s) && i.has(t)
                            ? (o = !1)
                            : (i.add(t), (n[e] = i));
                        }
                      }
                    }
                }
                return o;
              };
            })()
          )
          .reverse()
          .map((t, e) => {
            let n = t.key || e;
            if (
              !i &&
              "link" === t.type &&
              t.props.href &&
              [
                "https://fonts.googleapis.com/css",
                "https://use.typekit.net/",
              ].some((e) => t.props.href.startsWith(e))
            ) {
              let e = { ...(t.props || {}) };
              return (
                (e["data-href"] = e.href),
                (e.href = void 0),
                (e["data-optimized-fonts"] = !0),
                s.default.cloneElement(t, e)
              );
            }
            return s.default.cloneElement(t, { key: n });
          });
      }
      let m = function (t) {
        let { children: e } = t,
          i = (0, s.useContext)(l.AmpStateContext),
          n = (0, s.useContext)(u.HeadManagerContext);
        return (0, o.jsx)(a.default, {
          reduceComponentsToState: f,
          headManager: n,
          inAmpMode: (0, c.isInAmpMode)(i),
          children: e,
        });
      };
      ("function" == typeof e.default ||
        ("object" == typeof e.default && null !== e.default)) &&
        void 0 === e.default.__esModule &&
        (Object.defineProperty(e.default, "__esModule", { value: !0 }),
        Object.assign(e.default, e),
        (t.exports = e.default));
    },
    1564: function (t, e) {
      "use strict";
      function i(t) {
        let {
            widthInt: e,
            heightInt: i,
            blurWidth: n,
            blurHeight: r,
            blurDataURL: o,
            objectFit: s,
          } = t,
          a = n ? 40 * n : e,
          l = r ? 40 * r : i,
          u = a && l ? "viewBox='0 0 " + a + " " + l + "'" : "";
        return (
          "%3Csvg xmlns='http://www.w3.org/2000/svg' " +
          u +
          "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" +
          (u
            ? "none"
            : "contain" === s
            ? "xMidYMid"
            : "cover" === s
            ? "xMidYMid slice"
            : "none") +
          "' style='filter: url(%23b);' href='" +
          o +
          "'/%3E%3C/svg%3E"
        );
      }
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "getImageBlurSvg", {
          enumerable: !0,
          get: function () {
            return i;
          },
        });
    },
    3938: function (t, e, i) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "ImageConfigContext", {
          enumerable: !0,
          get: function () {
            return o;
          },
        });
      let n = i(9920)._(i(2265)),
        r = i(7103),
        o = n.default.createContext(r.imageConfigDefault);
    },
    7103: function (t, e) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (function (t, e) {
          for (var i in e)
            Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
        })(e, {
          VALID_LOADERS: function () {
            return i;
          },
          imageConfigDefault: function () {
            return n;
          },
        });
      let i = ["default", "imgix", "cloudinary", "akamai", "custom"],
        n = {
          deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
          imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
          path: "/_next/image",
          loader: "default",
          loaderFile: "",
          domains: [],
          disableStaticImages: !1,
          minimumCacheTTL: 60,
          formats: ["image/webp"],
          dangerouslyAllowSVG: !1,
          contentSecurityPolicy:
            "script-src 'none'; frame-src 'none'; sandbox;",
          contentDispositionType: "inline",
          remotePatterns: [],
          unoptimized: !1,
        };
    },
    5601: function (t, e, i) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (function (t, e) {
          for (var i in e)
            Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
        })(e, {
          default: function () {
            return l;
          },
          getImageProps: function () {
            return a;
          },
        });
      let n = i(9920),
        r = i(497),
        o = i(8173),
        s = n._(i(1241));
      function a(t) {
        let { props: e } = (0, r.getImgProps)(t, {
          defaultLoader: s.default,
          imgConf: {
            deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
            imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
            path: "/_next/image",
            loader: "default",
            dangerouslyAllowSVG: !1,
            unoptimized: !1,
          },
        });
        for (let [t, i] of Object.entries(e)) void 0 === i && delete e[t];
        return { props: e };
      }
      let l = o.Image;
    },
    1241: function (t, e) {
      "use strict";
      function i(t) {
        let { config: e, src: i, width: n, quality: r } = t;
        return i;
      }
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "default", {
          enumerable: !0,
          get: function () {
            return n;
          },
        }),
        (i.__next_img_default = !0);
      let n = i;
    },
    5960: function (t, e, i) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 }),
        Object.defineProperty(e, "default", {
          enumerable: !0,
          get: function () {
            return a;
          },
        });
      let n = i(2265),
        r = "undefined" == typeof window,
        o = r ? () => {} : n.useLayoutEffect,
        s = r ? () => {} : n.useEffect;
      function a(t) {
        let { headManager: e, reduceComponentsToState: i } = t;
        function a() {
          if (e && e.mountedInstances) {
            let r = n.Children.toArray(
              Array.from(e.mountedInstances).filter(Boolean)
            );
            e.updateHead(i(r, t));
          }
        }
        if (r) {
          var l;
          null == e || null == (l = e.mountedInstances) || l.add(t.children),
            a();
        }
        return (
          o(() => {
            var i;
            return (
              null == e ||
                null == (i = e.mountedInstances) ||
                i.add(t.children),
              () => {
                var i;
                null == e ||
                  null == (i = e.mountedInstances) ||
                  i.delete(t.children);
              }
            );
          }),
          o(
            () => (
              e && (e._pendingUpdate = a),
              () => {
                e && (e._pendingUpdate = a);
              }
            )
          ),
          s(
            () => (
              e &&
                e._pendingUpdate &&
                (e._pendingUpdate(), (e._pendingUpdate = null)),
              () => {
                e &&
                  e._pendingUpdate &&
                  (e._pendingUpdate(), (e._pendingUpdate = null));
              }
            )
          ),
          null
        );
      }
    },
    7586: function (t, e, i) {
      "use strict";
      function n(t) {
        return (n =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  "function" == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? "symbol"
                  : typeof t;
              })(t);
      }
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.CopyToClipboard = void 0);
      var r = a(i(2265)),
        o = a(i(42)),
        s = ["text", "onCopy", "options", "children"];
      function a(t) {
        return t && t.__esModule ? t : { default: t };
      }
      function l(t, e) {
        var i = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          e &&
            (n = n.filter(function (e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable;
            })),
            i.push.apply(i, n);
        }
        return i;
      }
      function u(t) {
        for (var e = 1; e < arguments.length; e++) {
          var i = null != arguments[e] ? arguments[e] : {};
          e % 2
            ? l(Object(i), !0).forEach(function (e) {
                p(t, e, i[e]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i))
            : l(Object(i)).forEach(function (e) {
                Object.defineProperty(
                  t,
                  e,
                  Object.getOwnPropertyDescriptor(i, e)
                );
              });
        }
        return t;
      }
      function c(t, e) {
        return (c =
          Object.setPrototypeOf ||
          function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
      }
      function h(t) {
        if (void 0 === t)
          throw ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function d(t) {
        return (d = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function (t) {
              return t.__proto__ || Object.getPrototypeOf(t);
            })(t);
      }
      function p(t, e, i) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = i),
          t
        );
      }
      var f = (function (t) {
        !(function (t, e) {
          if ("function" != typeof e && null !== e)
            throw TypeError(
              "Super expression must either be null or a function"
            );
          (t.prototype = Object.create(e && e.prototype, {
            constructor: { value: t, writable: !0, configurable: !0 },
          })),
            Object.defineProperty(t, "prototype", { writable: !1 }),
            e && c(t, e);
        })(l, t);
        var e,
          i,
          a =
            ((e = (function () {
              if (
                "undefined" == typeof Reflect ||
                !Reflect.construct ||
                Reflect.construct.sham
              )
                return !1;
              if ("function" == typeof Proxy) return !0;
              try {
                return (
                  Boolean.prototype.valueOf.call(
                    Reflect.construct(Boolean, [], function () {})
                  ),
                  !0
                );
              } catch (t) {
                return !1;
              }
            })()),
            function () {
              var t,
                i = d(l);
              return (
                (t = e
                  ? Reflect.construct(i, arguments, d(this).constructor)
                  : i.apply(this, arguments)),
                (function (t, e) {
                  if (e && ("object" === n(e) || "function" == typeof e))
                    return e;
                  if (void 0 !== e)
                    throw TypeError(
                      "Derived constructors may only return object or undefined"
                    );
                  return h(t);
                })(this, t)
              );
            });
        function l() {
          var t;
          !(function (t, e) {
            if (!(t instanceof e))
              throw TypeError("Cannot call a class as a function");
          })(this, l);
          for (var e = arguments.length, i = Array(e), n = 0; n < e; n++)
            i[n] = arguments[n];
          return (
            p(
              h((t = a.call.apply(a, [this].concat(i)))),
              "onClick",
              function (e) {
                var i = t.props,
                  n = i.text,
                  s = i.onCopy,
                  a = i.children,
                  l = i.options,
                  u = r.default.Children.only(a),
                  c = (0, o.default)(n, l);
                s && s(n, c),
                  u &&
                    u.props &&
                    "function" == typeof u.props.onClick &&
                    u.props.onClick(e);
              }
            ),
            t
          );
        }
        return (
          (i = [
            {
              key: "render",
              value: function () {
                var t = this.props,
                  e = (t.text, t.onCopy, t.options, t.children),
                  i = (function (t, e) {
                    if (null == t) return {};
                    var i,
                      n,
                      r = (function (t, e) {
                        if (null == t) return {};
                        var i,
                          n,
                          r = {},
                          o = Object.keys(t);
                        for (n = 0; n < o.length; n++)
                          (i = o[n]), e.indexOf(i) >= 0 || (r[i] = t[i]);
                        return r;
                      })(t, e);
                    if (Object.getOwnPropertySymbols) {
                      var o = Object.getOwnPropertySymbols(t);
                      for (n = 0; n < o.length; n++)
                        (i = o[n]),
                          !(e.indexOf(i) >= 0) &&
                            Object.prototype.propertyIsEnumerable.call(t, i) &&
                            (r[i] = t[i]);
                    }
                    return r;
                  })(t, s),
                  n = r.default.Children.only(e);
                return r.default.cloneElement(
                  n,
                  u(u({}, i), {}, { onClick: this.onClick })
                );
              },
            },
          ]),
          (function (t, e) {
            for (var i = 0; i < e.length; i++) {
              var n = e[i];
              (n.enumerable = n.enumerable || !1),
                (n.configurable = !0),
                "value" in n && (n.writable = !0),
                Object.defineProperty(t, n.key, n);
            }
          })(l.prototype, i),
          Object.defineProperty(l, "prototype", { writable: !1 }),
          l
        );
      })(r.default.PureComponent);
      (e.CopyToClipboard = f),
        p(f, "defaultProps", { onCopy: void 0, options: void 0 });
    },
    5789: function (t, e, i) {
      "use strict";
      var n = i(7586).CopyToClipboard;
      (n.CopyToClipboard = n), (t.exports = n);
    },
    5786: function (t) {
      t.exports = function () {
        var t = document.getSelection();
        if (!t.rangeCount) return function () {};
        for (
          var e = document.activeElement, i = [], n = 0;
          n < t.rangeCount;
          n++
        )
          i.push(t.getRangeAt(n));
        switch (e.tagName.toUpperCase()) {
          case "INPUT":
          case "TEXTAREA":
            e.blur();
            break;
          default:
            e = null;
        }
        return (
          t.removeAllRanges(),
          function () {
            "Caret" === t.type && t.removeAllRanges(),
              t.rangeCount ||
                i.forEach(function (e) {
                  t.addRange(e);
                }),
              e && e.focus();
          }
        );
      };
    },
    2012: function () {},
    6800: function (t, e) {
      var i;
      /*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ !(function () {
        "use strict";
        var n = {}.hasOwnProperty;
        function r() {
          for (var t = "", e = 0; e < arguments.length; e++) {
            var i = arguments[e];
            i &&
              (t = o(
                t,
                (function (t) {
                  if ("string" == typeof t || "number" == typeof t) return t;
                  if ("object" != typeof t) return "";
                  if (Array.isArray(t)) return r.apply(null, t);
                  if (
                    t.toString !== Object.prototype.toString &&
                    !t.toString.toString().includes("[native code]")
                  )
                    return t.toString();
                  var e = "";
                  for (var i in t) n.call(t, i) && t[i] && (e = o(e, i));
                  return e;
                })(i)
              ));
          }
          return t;
        }
        function o(t, e) {
          return e ? (t ? t + " " + e : t + e) : t;
        }
        t.exports
          ? ((r.default = r), (t.exports = r))
          : void 0 !==
              (i = function () {
                return r;
              }.apply(e, [])) && (t.exports = i);
      })();
    },
    9791: function (t, e, i) {
      "use strict";
      i.d(e, {
        _: function () {
          return n;
        },
      });
      let n = (0, i(2265).createContext)({
        transformPagePoint: (t) => t,
        isStatic: !1,
        reducedMotion: "never",
      });
    },
    2981: function (t, e, i) {
      "use strict";
      i.d(e, {
        Z: function () {
          return s;
        },
      });
      var n = i(565);
      class r {
        constructor() {
          (this.order = []), (this.scheduled = new Set());
        }
        add(t) {
          if (!this.scheduled.has(t))
            return this.scheduled.add(t), this.order.push(t), !0;
        }
        remove(t) {
          let e = this.order.indexOf(t);
          -1 !== e && (this.order.splice(e, 1), this.scheduled.delete(t));
        }
        clear() {
          (this.order.length = 0), this.scheduled.clear();
        }
      }
      let o = [
        "read",
        "resolveKeyframes",
        "update",
        "preRender",
        "render",
        "postRender",
      ];
      function s(t, e) {
        let i = !1,
          s = !0,
          a = { delta: 0, timestamp: 0, isProcessing: !1 },
          l = o.reduce(
            (t, e) => (
              (t[e] = (function (t) {
                let e = new r(),
                  i = new r(),
                  n = 0,
                  o = !1,
                  s = !1,
                  a = new WeakSet(),
                  l = {
                    schedule: (t, r = !1, s = !1) => {
                      let l = s && o,
                        u = l ? e : i;
                      return (
                        r && a.add(t),
                        u.add(t) && l && o && (n = e.order.length),
                        t
                      );
                    },
                    cancel: (t) => {
                      i.remove(t), a.delete(t);
                    },
                    process: (r) => {
                      if (o) {
                        s = !0;
                        return;
                      }
                      if (
                        ((o = !0),
                        ([e, i] = [i, e]),
                        i.clear(),
                        (n = e.order.length))
                      )
                        for (let i = 0; i < n; i++) {
                          let n = e.order[i];
                          a.has(n) && (l.schedule(n), t()), n(r);
                        }
                      (o = !1), s && ((s = !1), l.process(r));
                    },
                  };
                return l;
              })(() => (i = !0))),
              t
            ),
            {}
          ),
          u = (t) => {
            l[t].process(a);
          },
          c = () => {
            let r = n.c.useManualTiming ? a.timestamp : performance.now();
            (i = !1),
              (a.delta = s
                ? 1e3 / 60
                : Math.max(Math.min(r - a.timestamp, 40), 1)),
              (a.timestamp = r),
              (a.isProcessing = !0),
              o.forEach(u),
              (a.isProcessing = !1),
              i && e && ((s = !1), t(c));
          },
          h = () => {
            (i = !0), (s = !0), a.isProcessing || t(c);
          };
        return {
          schedule: o.reduce((t, e) => {
            let n = l[e];
            return (
              (t[e] = (t, e = !1, r = !1) => (i || h(), n.schedule(t, e, r))), t
            );
          }, {}),
          cancel: (t) => o.forEach((e) => l[e].cancel(t)),
          state: a,
          steps: l,
        };
      }
    },
    6219: function (t, e, i) {
      "use strict";
      i.d(e, {
        Pn: function () {
          return o;
        },
        S6: function () {
          return a;
        },
        Wi: function () {
          return r;
        },
        frameData: function () {
          return s;
        },
      });
      var n = i(9276);
      let {
        schedule: r,
        cancel: o,
        state: s,
        steps: a,
      } = (0, i(2981).Z)(
        "undefined" != typeof requestAnimationFrame
          ? requestAnimationFrame
          : n.Z,
        !0
      );
    },
    9993: function (t, e, i) {
      "use strict";
      let n;
      i.d(e, {
        X: function () {
          return a;
        },
      });
      var r = i(565),
        o = i(6219);
      function s() {
        n = void 0;
      }
      let a = {
        now: () => (
          void 0 === n &&
            a.set(
              o.frameData.isProcessing || r.c.useManualTiming
                ? o.frameData.timestamp
                : performance.now()
            ),
          n
        ),
        set: (t) => {
          (n = t), queueMicrotask(s);
        },
      };
    },
    7147: function (t, e, i) {
      "use strict";
      i.d(e, {
        E: function () {
          return ry;
        },
      });
      var n,
        r = i(7437),
        o = i(2265),
        s = i(9791);
      let a = (0, o.createContext)({}),
        l = (0, o.createContext)(null);
      var u = i(9033);
      let c = (0, o.createContext)({ strict: !1 }),
        h = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
        d = "data-" + h("framerAppearId"),
        { schedule: p, cancel: f } = (0, i(2981).Z)(queueMicrotask, !1);
      function m(t) {
        return (
          t &&
          "object" == typeof t &&
          Object.prototype.hasOwnProperty.call(t, "current")
        );
      }
      function v(t) {
        return "string" == typeof t || Array.isArray(t);
      }
      function y(t) {
        return (
          null !== t && "object" == typeof t && "function" == typeof t.start
        );
      }
      let g = [
          "animate",
          "whileInView",
          "whileFocus",
          "whileHover",
          "whileTap",
          "whileDrag",
          "exit",
        ],
        x = ["initial", ...g];
      function w(t) {
        return y(t.animate) || x.some((e) => v(t[e]));
      }
      function b(t) {
        return !!(w(t) || t.variants);
      }
      function S(t) {
        return Array.isArray(t) ? t.join(" ") : t;
      }
      let P = {
          animation: [
            "animate",
            "variants",
            "whileHover",
            "whileTap",
            "exit",
            "whileInView",
            "whileFocus",
            "whileDrag",
          ],
          exit: ["exit"],
          drag: ["drag", "dragControls"],
          focus: ["whileFocus"],
          hover: ["whileHover", "onHoverStart", "onHoverEnd"],
          tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
          pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
          inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
          layout: ["layout", "layoutId"],
        },
        T = {};
      for (let t in P) T[t] = { isEnabled: (e) => P[t].some((t) => !!e[t]) };
      var A = i(7282);
      let E = (0, o.createContext)({}),
        C = (0, o.createContext)({}),
        R = Symbol.for("motionComponentSymbol"),
        k = [
          "animate",
          "circle",
          "defs",
          "desc",
          "ellipse",
          "g",
          "image",
          "line",
          "filter",
          "marker",
          "mask",
          "metadata",
          "path",
          "pattern",
          "polygon",
          "polyline",
          "rect",
          "stop",
          "switch",
          "symbol",
          "svg",
          "text",
          "tspan",
          "use",
          "view",
        ];
      function V(t) {
        if ("string" != typeof t || t.includes("-"));
        else if (k.indexOf(t) > -1 || /[A-Z]/u.test(t)) return !0;
        return !1;
      }
      let O = {},
        D = [
          "transformPerspective",
          "x",
          "y",
          "z",
          "translateX",
          "translateY",
          "translateZ",
          "scale",
          "scaleX",
          "scaleY",
          "rotate",
          "rotateX",
          "rotateY",
          "rotateZ",
          "skew",
          "skewX",
          "skewY",
        ],
        M = new Set(D);
      function j(t, { layout: e, layoutId: i }) {
        return (
          M.has(t) ||
          t.startsWith("origin") ||
          ((e || void 0 !== i) && (!!O[t] || "opacity" === t))
        );
      }
      let _ = (t) => !!(t && t.getVelocity),
        L = {
          x: "translateX",
          y: "translateY",
          z: "translateZ",
          transformPerspective: "perspective",
        },
        F = D.length;
      var B = i(1534);
      let I = (t, e) => (e && "number" == typeof t ? e.transform(t) : t);
      var $ = i(783),
        W = i(5480);
      let N = { ...$.Rx, transform: Math.round },
        z = {
          borderWidth: W.px,
          borderTopWidth: W.px,
          borderRightWidth: W.px,
          borderBottomWidth: W.px,
          borderLeftWidth: W.px,
          borderRadius: W.px,
          radius: W.px,
          borderTopLeftRadius: W.px,
          borderTopRightRadius: W.px,
          borderBottomRightRadius: W.px,
          borderBottomLeftRadius: W.px,
          width: W.px,
          maxWidth: W.px,
          height: W.px,
          maxHeight: W.px,
          size: W.px,
          top: W.px,
          right: W.px,
          bottom: W.px,
          left: W.px,
          padding: W.px,
          paddingTop: W.px,
          paddingRight: W.px,
          paddingBottom: W.px,
          paddingLeft: W.px,
          margin: W.px,
          marginTop: W.px,
          marginRight: W.px,
          marginBottom: W.px,
          marginLeft: W.px,
          rotate: W.RW,
          rotateX: W.RW,
          rotateY: W.RW,
          rotateZ: W.RW,
          scale: $.bA,
          scaleX: $.bA,
          scaleY: $.bA,
          scaleZ: $.bA,
          skew: W.RW,
          skewX: W.RW,
          skewY: W.RW,
          distance: W.px,
          translateX: W.px,
          translateY: W.px,
          translateZ: W.px,
          x: W.px,
          y: W.px,
          z: W.px,
          perspective: W.px,
          transformPerspective: W.px,
          opacity: $.Fq,
          originX: W.$C,
          originY: W.$C,
          originZ: W.px,
          zIndex: N,
          backgroundPositionX: W.px,
          backgroundPositionY: W.px,
          fillOpacity: $.Fq,
          strokeOpacity: $.Fq,
          numOctaves: N,
        };
      function U(t, e, i, n) {
        let { style: r, vars: o, transform: s, transformOrigin: a } = t,
          l = !1,
          u = !1,
          c = !0;
        for (let t in e) {
          let i = e[t];
          if ((0, B.f)(t)) {
            o[t] = i;
            continue;
          }
          let n = z[t],
            h = I(i, n);
          if (M.has(t)) {
            if (((l = !0), (s[t] = h), !c)) continue;
            i !== (n.default || 0) && (c = !1);
          } else t.startsWith("origin") ? ((u = !0), (a[t] = h)) : (r[t] = h);
        }
        if (
          (!e.transform &&
            (l || n
              ? (r.transform = (function (
                  t,
                  {
                    enableHardwareAcceleration: e = !0,
                    allowTransformNone: i = !0,
                  },
                  n,
                  r
                ) {
                  let o = "";
                  for (let e = 0; e < F; e++) {
                    let i = D[e];
                    if (void 0 !== t[i]) {
                      let e = L[i] || i;
                      o += `${e}(${t[i]}) `;
                    }
                  }
                  return (
                    e && !t.z && (o += "translateZ(0)"),
                    (o = o.trim()),
                    r ? (o = r(t, n ? "" : o)) : i && n && (o = "none"),
                    o
                  );
                })(t.transform, i, c, n))
              : r.transform && (r.transform = "none")),
          u)
        ) {
          let { originX: t = "50%", originY: e = "50%", originZ: i = 0 } = a;
          r.transformOrigin = `${t} ${e} ${i}`;
        }
      }
      let H = () => ({
        style: {},
        transform: {},
        transformOrigin: {},
        vars: {},
      });
      function X(t, e, i) {
        for (let n in e) _(e[n]) || j(n, i) || (t[n] = e[n]);
      }
      let K = new Set([
        "animate",
        "exit",
        "variants",
        "initial",
        "style",
        "values",
        "variants",
        "transition",
        "transformTemplate",
        "custom",
        "inherit",
        "onBeforeLayoutMeasure",
        "onAnimationStart",
        "onAnimationComplete",
        "onUpdate",
        "onDragStart",
        "onDrag",
        "onDragEnd",
        "onMeasureDragConstraints",
        "onDirectionLock",
        "onDragTransitionEnd",
        "_dragX",
        "_dragY",
        "onHoverStart",
        "onHoverEnd",
        "onViewportEnter",
        "onViewportLeave",
        "globalTapTarget",
        "ignoreStrict",
        "viewport",
      ]);
      function Y(t) {
        return (
          t.startsWith("while") ||
          (t.startsWith("drag") && "draggable" !== t) ||
          t.startsWith("layout") ||
          t.startsWith("onTap") ||
          t.startsWith("onPan") ||
          t.startsWith("onLayout") ||
          K.has(t)
        );
      }
      let q = (t) => !Y(t);
      try {
        (n = require("@emotion/is-prop-valid").default) &&
          (q = (t) => (t.startsWith("on") ? !Y(t) : n(t)));
      } catch (t) {}
      function Z(t, e, i) {
        return "string" == typeof t ? t : W.px.transform(e + i * t);
      }
      let G = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
        J = { offset: "strokeDashoffset", array: "strokeDasharray" };
      function Q(
        t,
        {
          attrX: e,
          attrY: i,
          attrScale: n,
          originX: r,
          originY: o,
          pathLength: s,
          pathSpacing: a = 1,
          pathOffset: l = 0,
          ...u
        },
        c,
        h,
        d
      ) {
        if ((U(t, u, c, d), h)) {
          t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
          return;
        }
        (t.attrs = t.style), (t.style = {});
        let { attrs: p, style: f, dimensions: m } = t;
        p.transform && (m && (f.transform = p.transform), delete p.transform),
          m &&
            (void 0 !== r || void 0 !== o || f.transform) &&
            (f.transformOrigin = (function (t, e, i) {
              let n = Z(e, t.x, t.width),
                r = Z(i, t.y, t.height);
              return `${n} ${r}`;
            })(m, void 0 !== r ? r : 0.5, void 0 !== o ? o : 0.5)),
          void 0 !== e && (p.x = e),
          void 0 !== i && (p.y = i),
          void 0 !== n && (p.scale = n),
          void 0 !== s &&
            (function (t, e, i = 1, n = 0, r = !0) {
              t.pathLength = 1;
              let o = r ? G : J;
              t[o.offset] = W.px.transform(-n);
              let s = W.px.transform(e),
                a = W.px.transform(i);
              t[o.array] = `${s} ${a}`;
            })(p, s, a, l, !1);
      }
      let tt = () => ({ ...H(), attrs: {} }),
        te = (t) => "string" == typeof t && "svg" === t.toLowerCase();
      function ti(t, { style: e, vars: i }, n, r) {
        for (let o in (Object.assign(t.style, e, r && r.getProjectionStyles(n)),
        i))
          t.style.setProperty(o, i[o]);
      }
      let tn = new Set([
        "baseFrequency",
        "diffuseConstant",
        "kernelMatrix",
        "kernelUnitLength",
        "keySplines",
        "keyTimes",
        "limitingConeAngle",
        "markerHeight",
        "markerWidth",
        "numOctaves",
        "targetX",
        "targetY",
        "surfaceScale",
        "specularConstant",
        "specularExponent",
        "stdDeviation",
        "tableValues",
        "viewBox",
        "gradientTransform",
        "pathLength",
        "startOffset",
        "textLength",
        "lengthAdjust",
      ]);
      function tr(t, e, i, n) {
        for (let i in (ti(t, e, void 0, n), e.attrs))
          t.setAttribute(tn.has(i) ? i : h(i), e.attrs[i]);
      }
      function to(t, e, i) {
        var n;
        let { style: r } = t,
          o = {};
        for (let s in r)
          (_(r[s]) ||
            (e.style && _(e.style[s])) ||
            j(s, t) ||
            (null === (n = null == i ? void 0 : i.getValue(s)) || void 0 === n
              ? void 0
              : n.liveStyle) !== void 0) &&
            (o[s] = r[s]);
        return o;
      }
      function ts(t, e, i) {
        let n = to(t, e, i);
        for (let i in t)
          (_(t[i]) || _(e[i])) &&
            (n[
              -1 !== D.indexOf(i)
                ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
                : i
            ] = t[i]);
        return n;
      }
      function ta(t) {
        let e = [{}, {}];
        return (
          null == t ||
            t.values.forEach((t, i) => {
              (e[0][i] = t.get()), (e[1][i] = t.getVelocity());
            }),
          e
        );
      }
      function tl(t, e, i, n) {
        if ("function" == typeof e) {
          let [r, o] = ta(n);
          e = e(void 0 !== i ? i : t.custom, r, o);
        }
        if (
          ("string" == typeof e && (e = t.variants && t.variants[e]),
          "function" == typeof e)
        ) {
          let [r, o] = ta(n);
          e = e(void 0 !== i ? i : t.custom, r, o);
        }
        return e;
      }
      var tu = i(458);
      let tc = (t) => Array.isArray(t),
        th = (t) => !!(t && "object" == typeof t && t.mix && t.toValue),
        td = (t) => (tc(t) ? t[t.length - 1] || 0 : t);
      function tp(t) {
        let e = _(t) ? t.get() : t;
        return th(e) ? e.toValue() : e;
      }
      let tf = (t) => (e, i) => {
        let n = (0, o.useContext)(a),
          r = (0, o.useContext)(l),
          s = () =>
            (function (
              {
                scrapeMotionValuesFromProps: t,
                createRenderState: e,
                onMount: i,
              },
              n,
              r,
              o
            ) {
              let s = {
                latestValues: (function (t, e, i, n) {
                  let r = {},
                    o = n(t, {});
                  for (let t in o) r[t] = tp(o[t]);
                  let { initial: s, animate: a } = t,
                    l = w(t),
                    u = b(t);
                  e &&
                    u &&
                    !l &&
                    !1 !== t.inherit &&
                    (void 0 === s && (s = e.initial),
                    void 0 === a && (a = e.animate));
                  let c = !!i && !1 === i.initial,
                    h = (c = c || !1 === s) ? a : s;
                  return (
                    h &&
                      "boolean" != typeof h &&
                      !y(h) &&
                      (Array.isArray(h) ? h : [h]).forEach((e) => {
                        let i = tl(t, e);
                        if (!i) return;
                        let { transitionEnd: n, transition: o, ...s } = i;
                        for (let t in s) {
                          let e = s[t];
                          if (Array.isArray(e)) {
                            let t = c ? e.length - 1 : 0;
                            e = e[t];
                          }
                          null !== e && (r[t] = e);
                        }
                        for (let t in n) r[t] = n[t];
                      }),
                    r
                  );
                })(n, r, o, t),
                renderState: e(),
              };
              return i && (s.mount = (t) => i(n, t, s)), s;
            })(t, e, n, r);
        return i ? s() : (0, tu.h)(s);
      };
      var tm = i(6219);
      let tv = {
          useVisualState: tf({
            scrapeMotionValuesFromProps: ts,
            createRenderState: tt,
            onMount: (t, e, { renderState: i, latestValues: n }) => {
              tm.Wi.read(() => {
                try {
                  i.dimensions =
                    "function" == typeof e.getBBox
                      ? e.getBBox()
                      : e.getBoundingClientRect();
                } catch (t) {
                  i.dimensions = { x: 0, y: 0, width: 0, height: 0 };
                }
              }),
                tm.Wi.render(() => {
                  Q(
                    i,
                    n,
                    { enableHardwareAcceleration: !1 },
                    te(e.tagName),
                    t.transformTemplate
                  ),
                    tr(e, i);
                });
            },
          }),
        },
        ty = {
          useVisualState: tf({
            scrapeMotionValuesFromProps: to,
            createRenderState: H,
          }),
        };
      function tg(t, e, i, n = { passive: !0 }) {
        return t.addEventListener(e, i, n), () => t.removeEventListener(e, i);
      }
      let tx = (t) =>
        "mouse" === t.pointerType
          ? "number" != typeof t.button || t.button <= 0
          : !1 !== t.isPrimary;
      function tw(t, e = "page") {
        return { point: { x: t[`${e}X`], y: t[`${e}Y`] } };
      }
      let tb = (t) => (e) => tx(e) && t(e, tw(e));
      function tS(t, e, i, n) {
        return tg(t, e, tb(i), n);
      }
      var tP = i(9654);
      function tT(t) {
        let e = null;
        return () =>
          null === e &&
          ((e = t),
          () => {
            e = null;
          });
      }
      let tA = tT("dragHorizontal"),
        tE = tT("dragVertical");
      function tC(t) {
        let e = !1;
        if ("y" === t) e = tE();
        else if ("x" === t) e = tA();
        else {
          let t = tA(),
            i = tE();
          t && i
            ? (e = () => {
                t(), i();
              })
            : (t && t(), i && i());
        }
        return e;
      }
      function tR() {
        let t = tC(!0);
        return !t || (t(), !1);
      }
      class tk {
        constructor(t) {
          (this.isMounted = !1), (this.node = t);
        }
        update() {}
      }
      function tV(t, e) {
        let i = e ? "onHoverStart" : "onHoverEnd";
        return tS(
          t.current,
          e ? "pointerenter" : "pointerleave",
          (n, r) => {
            if ("touch" === n.pointerType || tR()) return;
            let o = t.getProps();
            t.animationState &&
              o.whileHover &&
              t.animationState.setActive("whileHover", e);
            let s = o[i];
            s && tm.Wi.postRender(() => s(n, r));
          },
          { passive: !t.getProps()[i] }
        );
      }
      class tO extends tk {
        mount() {
          this.unmount = (0, tP.z)(tV(this.node, !0), tV(this.node, !1));
        }
        unmount() {}
      }
      class tD extends tk {
        constructor() {
          super(...arguments), (this.isActive = !1);
        }
        onFocus() {
          let t = !1;
          try {
            t = this.node.current.matches(":focus-visible");
          } catch (e) {
            t = !0;
          }
          t &&
            this.node.animationState &&
            (this.node.animationState.setActive("whileFocus", !0),
            (this.isActive = !0));
        }
        onBlur() {
          this.isActive &&
            this.node.animationState &&
            (this.node.animationState.setActive("whileFocus", !1),
            (this.isActive = !1));
        }
        mount() {
          this.unmount = (0, tP.z)(
            tg(this.node.current, "focus", () => this.onFocus()),
            tg(this.node.current, "blur", () => this.onBlur())
          );
        }
        unmount() {}
      }
      let tM = (t, e) => !!e && (t === e || tM(t, e.parentElement));
      var tj = i(9276);
      function t_(t, e) {
        if (!e) return;
        let i = new PointerEvent("pointer" + t);
        e(i, tw(i));
      }
      class tL extends tk {
        constructor() {
          super(...arguments),
            (this.removeStartListeners = tj.Z),
            (this.removeEndListeners = tj.Z),
            (this.removeAccessibleListeners = tj.Z),
            (this.startPointerPress = (t, e) => {
              if (this.isPressing) return;
              this.removeEndListeners();
              let i = this.node.getProps(),
                n = tS(
                  window,
                  "pointerup",
                  (t, e) => {
                    if (!this.checkPressEnd()) return;
                    let {
                        onTap: i,
                        onTapCancel: n,
                        globalTapTarget: r,
                      } = this.node.getProps(),
                      o = r || tM(this.node.current, t.target) ? i : n;
                    o && tm.Wi.update(() => o(t, e));
                  },
                  { passive: !(i.onTap || i.onPointerUp) }
                ),
                r = tS(
                  window,
                  "pointercancel",
                  (t, e) => this.cancelPress(t, e),
                  { passive: !(i.onTapCancel || i.onPointerCancel) }
                );
              (this.removeEndListeners = (0, tP.z)(n, r)),
                this.startPress(t, e);
            }),
            (this.startAccessiblePress = () => {
              let t = tg(this.node.current, "keydown", (t) => {
                  "Enter" !== t.key ||
                    this.isPressing ||
                    (this.removeEndListeners(),
                    (this.removeEndListeners = tg(
                      this.node.current,
                      "keyup",
                      (t) => {
                        "Enter" === t.key &&
                          this.checkPressEnd() &&
                          t_("up", (t, e) => {
                            let { onTap: i } = this.node.getProps();
                            i && tm.Wi.postRender(() => i(t, e));
                          });
                      }
                    )),
                    t_("down", (t, e) => {
                      this.startPress(t, e);
                    }));
                }),
                e = tg(this.node.current, "blur", () => {
                  this.isPressing &&
                    t_("cancel", (t, e) => this.cancelPress(t, e));
                });
              this.removeAccessibleListeners = (0, tP.z)(t, e);
            });
        }
        startPress(t, e) {
          this.isPressing = !0;
          let { onTapStart: i, whileTap: n } = this.node.getProps();
          n &&
            this.node.animationState &&
            this.node.animationState.setActive("whileTap", !0),
            i && tm.Wi.postRender(() => i(t, e));
        }
        checkPressEnd() {
          return (
            this.removeEndListeners(),
            (this.isPressing = !1),
            this.node.getProps().whileTap &&
              this.node.animationState &&
              this.node.animationState.setActive("whileTap", !1),
            !tR()
          );
        }
        cancelPress(t, e) {
          if (!this.checkPressEnd()) return;
          let { onTapCancel: i } = this.node.getProps();
          i && tm.Wi.postRender(() => i(t, e));
        }
        mount() {
          let t = this.node.getProps(),
            e = tS(
              t.globalTapTarget ? window : this.node.current,
              "pointerdown",
              this.startPointerPress,
              { passive: !(t.onTapStart || t.onPointerStart) }
            ),
            i = tg(this.node.current, "focus", this.startAccessiblePress);
          this.removeStartListeners = (0, tP.z)(e, i);
        }
        unmount() {
          this.removeStartListeners(),
            this.removeEndListeners(),
            this.removeAccessibleListeners();
        }
      }
      let tF = new WeakMap(),
        tB = new WeakMap(),
        tI = (t) => {
          let e = tF.get(t.target);
          e && e(t);
        },
        t$ = (t) => {
          t.forEach(tI);
        },
        tW = { some: 0, all: 1 };
      class tN extends tk {
        constructor() {
          super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
        }
        startObserver() {
          this.unmount();
          let { viewport: t = {} } = this.node.getProps(),
            { root: e, margin: i, amount: n = "some", once: r } = t,
            o = {
              root: e ? e.current : void 0,
              rootMargin: i,
              threshold: "number" == typeof n ? n : tW[n],
            };
          return (function (t, e, i) {
            let n = (function ({ root: t, ...e }) {
              let i = t || document;
              tB.has(i) || tB.set(i, {});
              let n = tB.get(i),
                r = JSON.stringify(e);
              return (
                n[r] ||
                  (n[r] = new IntersectionObserver(t$, { root: t, ...e })),
                n[r]
              );
            })(e);
            return (
              tF.set(t, i),
              n.observe(t),
              () => {
                tF.delete(t), n.unobserve(t);
              }
            );
          })(this.node.current, o, (t) => {
            let { isIntersecting: e } = t;
            if (
              this.isInView === e ||
              ((this.isInView = e), r && !e && this.hasEnteredView)
            )
              return;
            e && (this.hasEnteredView = !0),
              this.node.animationState &&
                this.node.animationState.setActive("whileInView", e);
            let { onViewportEnter: i, onViewportLeave: n } =
                this.node.getProps(),
              o = e ? i : n;
            o && o(t);
          });
        }
        mount() {
          this.startObserver();
        }
        update() {
          if ("undefined" == typeof IntersectionObserver) return;
          let { props: t, prevProps: e } = this.node;
          ["amount", "margin", "root"].some(
            (function ({ viewport: t = {} }, { viewport: e = {} } = {}) {
              return (i) => t[i] !== e[i];
            })(t, e)
          ) && this.startObserver();
        }
        unmount() {}
      }
      function tz(t, e) {
        if (!Array.isArray(e)) return !1;
        let i = e.length;
        if (i !== t.length) return !1;
        for (let n = 0; n < i; n++) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function tU(t, e, i) {
        let n = t.getProps();
        return tl(n, e, void 0 !== i ? i : n.custom, t);
      }
      let tH = (t) => 1e3 * t,
        tX = (t) => t / 1e3,
        tK = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
        tY = (t) => ({
          type: "spring",
          stiffness: 550,
          damping: 0 === t ? 2 * Math.sqrt(550) : 30,
          restSpeed: 10,
        }),
        tq = { type: "keyframes", duration: 0.8 },
        tZ = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
        tG = (t, { keyframes: e }) =>
          e.length > 2
            ? tq
            : M.has(t)
            ? t.startsWith("scale")
              ? tY(e[1])
              : tK
            : tZ;
      function tJ(t, e) {
        return t[e] || t.default || t;
      }
      var tQ = i(565);
      let t0 = { current: !1 },
        t1 = (t) => null !== t;
      function t2(t, { repeat: e, repeatType: i = "loop" }, n) {
        let r = t.filter(t1),
          o = e && "loop" !== i && e % 2 == 1 ? 0 : r.length - 1;
        return o && void 0 !== n ? n : r[o];
      }
      var t5 = i(9993);
      let t3 = (t) => /^0[^.\s]+$/u.test(t);
      var t6 = i(9047);
      let t4 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),
        t9 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u,
        t8 = new Set([
          "width",
          "height",
          "top",
          "left",
          "right",
          "bottom",
          "x",
          "y",
          "translateX",
          "translateY",
        ]),
        t7 = (t) => t === $.Rx || t === W.px,
        et = (t, e) => parseFloat(t.split(", ")[e]),
        ee =
          (t, e) =>
          (i, { transform: n }) => {
            if ("none" === n || !n) return 0;
            let r = n.match(/^matrix3d\((.+)\)$/u);
            if (r) return et(r[1], e);
            {
              let e = n.match(/^matrix\((.+)\)$/u);
              return e ? et(e[1], t) : 0;
            }
          },
        ei = new Set(["x", "y", "z"]),
        en = D.filter((t) => !ei.has(t)),
        er = {
          width: ({ x: t }, { paddingLeft: e = "0", paddingRight: i = "0" }) =>
            t.max - t.min - parseFloat(e) - parseFloat(i),
          height: ({ y: t }, { paddingTop: e = "0", paddingBottom: i = "0" }) =>
            t.max - t.min - parseFloat(e) - parseFloat(i),
          top: (t, { top: e }) => parseFloat(e),
          left: (t, { left: e }) => parseFloat(e),
          bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
          right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
          x: ee(4, 13),
          y: ee(5, 14),
        };
      (er.translateX = er.x), (er.translateY = er.y);
      let eo = (t) => (e) => e.test(t),
        es = [
          $.Rx,
          W.px,
          W.aQ,
          W.RW,
          W.vw,
          W.vh,
          { test: (t) => "auto" === t, parse: (t) => t },
        ],
        ea = (t) => es.find(eo(t)),
        el = new Set(),
        eu = !1,
        ec = !1;
      function eh() {
        if (ec) {
          let t = Array.from(el).filter((t) => t.needsMeasurement),
            e = new Set(t.map((t) => t.element)),
            i = new Map();
          e.forEach((t) => {
            let e = (function (t) {
              let e = [];
              return (
                en.forEach((i) => {
                  let n = t.getValue(i);
                  void 0 !== n &&
                    (e.push([i, n.get()]),
                    n.set(i.startsWith("scale") ? 1 : 0));
                }),
                e
              );
            })(t);
            e.length && (i.set(t, e), t.render());
          }),
            t.forEach((t) => t.measureInitialState()),
            e.forEach((t) => {
              t.render();
              let e = i.get(t);
              e &&
                e.forEach(([e, i]) => {
                  var n;
                  null === (n = t.getValue(e)) || void 0 === n || n.set(i);
                });
            }),
            t.forEach((t) => t.measureEndState()),
            t.forEach((t) => {
              void 0 !== t.suspendedScrollY &&
                window.scrollTo(0, t.suspendedScrollY);
            });
        }
        (ec = !1), (eu = !1), el.forEach((t) => t.complete()), el.clear();
      }
      function ed() {
        el.forEach((t) => {
          t.readKeyframes(), t.needsMeasurement && (ec = !0);
        });
      }
      class ep {
        constructor(t, e, i, n, r, o = !1) {
          (this.isComplete = !1),
            (this.isAsync = !1),
            (this.needsMeasurement = !1),
            (this.isScheduled = !1),
            (this.unresolvedKeyframes = [...t]),
            (this.onComplete = e),
            (this.name = i),
            (this.motionValue = n),
            (this.element = r),
            (this.isAsync = o);
        }
        scheduleResolve() {
          (this.isScheduled = !0),
            this.isAsync
              ? (el.add(this),
                eu || ((eu = !0), tm.Wi.read(ed), tm.Wi.resolveKeyframes(eh)))
              : (this.readKeyframes(), this.complete());
        }
        readKeyframes() {
          let {
            unresolvedKeyframes: t,
            name: e,
            element: i,
            motionValue: n,
          } = this;
          for (let r = 0; r < t.length; r++)
            if (null === t[r]) {
              if (0 === r) {
                let r = null == n ? void 0 : n.get(),
                  o = t[t.length - 1];
                if (void 0 !== r) t[0] = r;
                else if (i && e) {
                  let n = i.readValue(e, o);
                  null != n && (t[0] = n);
                }
                void 0 === t[0] && (t[0] = o), n && void 0 === r && n.set(t[0]);
              } else t[r] = t[r - 1];
            }
        }
        setFinalKeyframe() {}
        measureInitialState() {}
        renderEndStyles() {}
        measureEndState() {}
        complete() {
          (this.isComplete = !0),
            this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
            el.delete(this);
        }
        cancel() {
          this.isComplete || ((this.isScheduled = !1), el.delete(this));
        }
        resume() {
          this.isComplete || this.scheduleResolve();
        }
      }
      var ef = i(3646),
        em = i(7292);
      let ev = new Set(["brightness", "contrast", "saturate", "opacity"]);
      function ey(t) {
        let [e, i] = t.slice(0, -1).split("(");
        if ("drop-shadow" === e) return t;
        let [n] = i.match(em.KP) || [];
        if (!n) return t;
        let r = i.replace(n, ""),
          o = ev.has(e) ? 1 : 0;
        return n !== i && (o *= 100), e + "(" + o + r + ")";
      }
      let eg = /\b([a-z-]*)\(.*?\)/gu,
        ex = {
          ...ef.P,
          getAnimatableNone: (t) => {
            let e = t.match(eg);
            return e ? e.map(ey).join(" ") : t;
          },
        };
      var ew = i(146);
      let eb = {
          ...z,
          color: ew.$,
          backgroundColor: ew.$,
          outlineColor: ew.$,
          fill: ew.$,
          stroke: ew.$,
          borderColor: ew.$,
          borderTopColor: ew.$,
          borderRightColor: ew.$,
          borderBottomColor: ew.$,
          borderLeftColor: ew.$,
          filter: ex,
          WebkitFilter: ex,
        },
        eS = (t) => eb[t];
      function eP(t, e) {
        let i = eS(t);
        return (
          i !== ex && (i = ef.P),
          i.getAnimatableNone ? i.getAnimatableNone(e) : void 0
        );
      }
      let eT = new Set(["auto", "none", "0"]);
      class eA extends ep {
        constructor(t, e, i, n) {
          super(t, e, i, n, null == n ? void 0 : n.owner, !0);
        }
        readKeyframes() {
          let { unresolvedKeyframes: t, element: e, name: i } = this;
          if (!e.current) return;
          super.readKeyframes();
          for (let i = 0; i < t.length; i++) {
            let n = t[i];
            if ("string" == typeof n && ((n = n.trim()), (0, B.t)(n))) {
              let r = (function t(e, i, n = 1) {
                (0, t6.k)(
                  n <= 4,
                  `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`
                );
                let [r, o] = (function (t) {
                  let e = t9.exec(t);
                  if (!e) return [,];
                  let [, i, n, r] = e;
                  return [`--${null != i ? i : n}`, r];
                })(e);
                if (!r) return;
                let s = window.getComputedStyle(i).getPropertyValue(r);
                if (s) {
                  let t = s.trim();
                  return t4(t) ? parseFloat(t) : t;
                }
                return (0, B.t)(o) ? t(o, i, n + 1) : o;
              })(n, e.current);
              void 0 !== r && (t[i] = r),
                i === t.length - 1 && (this.finalKeyframe = n);
            }
          }
          if ((this.resolveNoneKeyframes(), !t8.has(i) || 2 !== t.length))
            return;
          let [n, r] = t,
            o = ea(n),
            s = ea(r);
          if (o !== s) {
            if (t7(o) && t7(s))
              for (let e = 0; e < t.length; e++) {
                let i = t[e];
                "string" == typeof i && (t[e] = parseFloat(i));
              }
            else this.needsMeasurement = !0;
          }
        }
        resolveNoneKeyframes() {
          let { unresolvedKeyframes: t, name: e } = this,
            i = [];
          for (let e = 0; e < t.length; e++) {
            var n;
            ("number" == typeof (n = t[e])
              ? 0 === n
              : null === n || "none" === n || "0" === n || t3(n)) && i.push(e);
          }
          i.length &&
            (function (t, e, i) {
              let n,
                r = 0;
              for (; r < t.length && !n; ) {
                let e = t[r];
                "string" == typeof e &&
                  !eT.has(e) &&
                  (0, ef.V)(e).values.length &&
                  (n = t[r]),
                  r++;
              }
              if (n && i) for (let r of e) t[r] = eP(i, n);
            })(t, i, e);
        }
        measureInitialState() {
          let { element: t, unresolvedKeyframes: e, name: i } = this;
          if (!t.current) return;
          "height" === i && (this.suspendedScrollY = window.pageYOffset),
            (this.measuredOrigin = er[i](
              t.measureViewportBox(),
              window.getComputedStyle(t.current)
            )),
            (e[0] = this.measuredOrigin);
          let n = e[e.length - 1];
          void 0 !== n && t.getValue(i, n).jump(n, !1);
        }
        measureEndState() {
          var t;
          let { element: e, name: i, unresolvedKeyframes: n } = this;
          if (!e.current) return;
          let r = e.getValue(i);
          r && r.jump(this.measuredOrigin, !1);
          let o = n.length - 1,
            s = n[o];
          (n[o] = er[i](
            e.measureViewportBox(),
            window.getComputedStyle(e.current)
          )),
            null !== s &&
              void 0 === this.finalKeyframe &&
              (this.finalKeyframe = s),
            (null === (t = this.removedTransforms) || void 0 === t
              ? void 0
              : t.length) &&
              this.removedTransforms.forEach(([t, i]) => {
                e.getValue(t).set(i);
              }),
            this.resolveNoneKeyframes();
        }
      }
      function eE(t) {
        let e;
        return () => (void 0 === e && (e = t()), e);
      }
      let eC = (t, e) =>
        "zIndex" !== e &&
        !!(
          "number" == typeof t ||
          Array.isArray(t) ||
          ("string" == typeof t &&
            (ef.P.test(t) || "0" === t) &&
            !t.startsWith("url("))
        );
      class eR {
        constructor({
          autoplay: t = !0,
          delay: e = 0,
          type: i = "keyframes",
          repeat: n = 0,
          repeatDelay: r = 0,
          repeatType: o = "loop",
          ...s
        }) {
          (this.isStopped = !1),
            (this.hasAttemptedResolve = !1),
            (this.options = {
              autoplay: t,
              delay: e,
              type: i,
              repeat: n,
              repeatDelay: r,
              repeatType: o,
              ...s,
            }),
            this.updateFinishedPromise();
        }
        get resolved() {
          return (
            this._resolved || this.hasAttemptedResolve || (ed(), eh()),
            this._resolved
          );
        }
        onKeyframesResolved(t, e) {
          this.hasAttemptedResolve = !0;
          let {
            name: i,
            type: n,
            velocity: r,
            delay: o,
            onComplete: s,
            onUpdate: a,
            isGenerator: l,
          } = this.options;
          if (
            !l &&
            !(function (t, e, i, n) {
              let r = t[0];
              if (null === r) return !1;
              if ("display" === e || "visibility" === e) return !0;
              let o = t[t.length - 1],
                s = eC(r, e),
                a = eC(o, e);
              return (
                (0, t6.K)(
                  s === a,
                  `You are trying to animate ${e} from "${r}" to "${o}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${o} via the \`style\` property.`
                ),
                !!s &&
                  !!a &&
                  ((function (t) {
                    let e = t[0];
                    if (1 === t.length) return !0;
                    for (let i = 0; i < t.length; i++)
                      if (t[i] !== e) return !0;
                  })(t) ||
                    ("spring" === i && n))
              );
            })(t, i, n, r)
          ) {
            if (t0.current || !o) {
              null == a || a(t2(t, this.options, e)),
                null == s || s(),
                this.resolveFinishedPromise();
              return;
            }
            this.options.duration = 0;
          }
          let u = this.initPlayback(t, e);
          !1 !== u &&
            ((this._resolved = { keyframes: t, finalKeyframe: e, ...u }),
            this.onPostResolved());
        }
        onPostResolved() {}
        then(t, e) {
          return this.currentFinishedPromise.then(t, e);
        }
        updateFinishedPromise() {
          this.currentFinishedPromise = new Promise((t) => {
            this.resolveFinishedPromise = t;
          });
        }
      }
      var ek = i(3476);
      function eV(t, e, i) {
        let n = Math.max(e - 5, 0);
        return (0, ek.R)(i - t(n), e - n);
      }
      var eO = i(1506);
      function eD(t, e) {
        return t * Math.sqrt(1 - e * e);
      }
      let eM = ["duration", "bounce"],
        ej = ["stiffness", "damping", "mass"];
      function e_(t, e) {
        return e.some((e) => void 0 !== t[e]);
      }
      function eL({ keyframes: t, restDelta: e, restSpeed: i, ...n }) {
        let r;
        let o = t[0],
          s = t[t.length - 1],
          a = { done: !1, value: o },
          {
            stiffness: l,
            damping: u,
            mass: c,
            duration: h,
            velocity: d,
            isResolvedFromDuration: p,
          } = (function (t) {
            let e = {
              velocity: 0,
              stiffness: 100,
              damping: 10,
              mass: 1,
              isResolvedFromDuration: !1,
              ...t,
            };
            if (!e_(t, ej) && e_(t, eM)) {
              let i = (function ({
                duration: t = 800,
                bounce: e = 0.25,
                velocity: i = 0,
                mass: n = 1,
              }) {
                let r, o;
                (0, t6.K)(
                  t <= tH(10),
                  "Spring duration must be 10 seconds or less"
                );
                let s = 1 - e;
                (s = (0, eO.u)(0.05, 1, s)),
                  (t = (0, eO.u)(0.01, 10, tX(t))),
                  s < 1
                    ? ((r = (e) => {
                        let n = e * s,
                          r = n * t;
                        return 0.001 - ((n - i) / eD(e, s)) * Math.exp(-r);
                      }),
                      (o = (e) => {
                        let n = e * s * t,
                          o = Math.pow(s, 2) * Math.pow(e, 2) * t,
                          a = eD(Math.pow(e, 2), s);
                        return (
                          ((n * i + i - o) *
                            Math.exp(-n) *
                            (-r(e) + 0.001 > 0 ? -1 : 1)) /
                          a
                        );
                      }))
                    : ((r = (e) =>
                        -0.001 + Math.exp(-e * t) * ((e - i) * t + 1)),
                      (o = (e) => t * t * (i - e) * Math.exp(-e * t)));
                let a = (function (t, e, i) {
                  let n = i;
                  for (let i = 1; i < 12; i++) n -= t(n) / e(n);
                  return n;
                })(r, o, 5 / t);
                if (((t = tH(t)), isNaN(a)))
                  return { stiffness: 100, damping: 10, duration: t };
                {
                  let e = Math.pow(a, 2) * n;
                  return {
                    stiffness: e,
                    damping: 2 * s * Math.sqrt(n * e),
                    duration: t,
                  };
                }
              })(t);
              (e = { ...e, ...i, mass: 1 }).isResolvedFromDuration = !0;
            }
            return e;
          })({ ...n, velocity: -tX(n.velocity || 0) }),
          f = d || 0,
          m = u / (2 * Math.sqrt(l * c)),
          v = s - o,
          y = tX(Math.sqrt(l / c)),
          g = 5 > Math.abs(v);
        if ((i || (i = g ? 0.01 : 2), e || (e = g ? 0.005 : 0.5), m < 1)) {
          let t = eD(y, m);
          r = (e) =>
            s -
            Math.exp(-m * y * e) *
              (((f + m * y * v) / t) * Math.sin(t * e) + v * Math.cos(t * e));
        } else if (1 === m)
          r = (t) => s - Math.exp(-y * t) * (v + (f + y * v) * t);
        else {
          let t = y * Math.sqrt(m * m - 1);
          r = (e) => {
            let i = Math.exp(-m * y * e),
              n = Math.min(t * e, 300);
            return (
              s -
              (i * ((f + m * y * v) * Math.sinh(n) + t * v * Math.cosh(n))) / t
            );
          };
        }
        return {
          calculatedDuration: (p && h) || null,
          next: (t) => {
            let n = r(t);
            if (p) a.done = t >= h;
            else {
              let o = f;
              0 !== t && (o = m < 1 ? eV(r, t, n) : 0);
              let l = Math.abs(o) <= i,
                u = Math.abs(s - n) <= e;
              a.done = l && u;
            }
            return (a.value = a.done ? s : n), a;
          },
        };
      }
      function eF({
        keyframes: t,
        velocity: e = 0,
        power: i = 0.8,
        timeConstant: n = 325,
        bounceDamping: r = 10,
        bounceStiffness: o = 500,
        modifyTarget: s,
        min: a,
        max: l,
        restDelta: u = 0.5,
        restSpeed: c,
      }) {
        let h, d;
        let p = t[0],
          f = { done: !1, value: p },
          m = (t) => (void 0 !== a && t < a) || (void 0 !== l && t > l),
          v = (t) =>
            void 0 === a
              ? l
              : void 0 === l
              ? a
              : Math.abs(a - t) < Math.abs(l - t)
              ? a
              : l,
          y = i * e,
          g = p + y,
          x = void 0 === s ? g : s(g);
        x !== g && (y = x - p);
        let w = (t) => -y * Math.exp(-t / n),
          b = (t) => x + w(t),
          S = (t) => {
            let e = w(t),
              i = b(t);
            (f.done = Math.abs(e) <= u), (f.value = f.done ? x : i);
          },
          P = (t) => {
            m(f.value) &&
              ((h = t),
              (d = eL({
                keyframes: [f.value, v(f.value)],
                velocity: eV(b, t, f.value),
                damping: r,
                stiffness: o,
                restDelta: u,
                restSpeed: c,
              })));
          };
        return (
          P(0),
          {
            calculatedDuration: null,
            next: (t) => {
              let e = !1;
              return (d || void 0 !== h || ((e = !0), S(t), P(t)),
              void 0 !== h && t >= h)
                ? d.next(t - h)
                : (e || S(t), f);
            },
          }
        );
      }
      let eB = (t, e, i) =>
        (((1 - 3 * i + 3 * e) * t + (3 * i - 6 * e)) * t + 3 * e) * t;
      function eI(t, e, i, n) {
        if (t === e && i === n) return tj.Z;
        let r = (e) =>
          (function (t, e, i, n, r) {
            let o, s;
            let a = 0;
            do
              (o = eB((s = e + (i - e) / 2), n, r) - t) > 0 ? (i = s) : (e = s);
            while (Math.abs(o) > 1e-7 && ++a < 12);
            return s;
          })(e, 0, 1, t, i);
        return (t) => (0 === t || 1 === t ? t : eB(r(t), e, n));
      }
      let e$ = eI(0.42, 0, 1, 1),
        eW = eI(0, 0, 0.58, 1),
        eN = eI(0.42, 0, 0.58, 1),
        ez = (t) => Array.isArray(t) && "number" != typeof t[0],
        eU = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,
        eH = (t) => (e) => 1 - t(1 - e),
        eX = (t) => 1 - Math.sin(Math.acos(t)),
        eK = eH(eX),
        eY = eU(eX),
        eq = eI(0.33, 1.53, 0.69, 0.99),
        eZ = eH(eq),
        eG = eU(eZ),
        eJ = {
          linear: tj.Z,
          easeIn: e$,
          easeInOut: eN,
          easeOut: eW,
          circIn: eX,
          circInOut: eY,
          circOut: eK,
          backIn: eZ,
          backInOut: eG,
          backOut: eq,
          anticipate: (t) =>
            (t *= 2) < 1 ? 0.5 * eZ(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))),
        },
        eQ = (t) => {
          if (Array.isArray(t)) {
            (0, t6.k)(
              4 === t.length,
              "Cubic bezier arrays must contain four numerical values."
            );
            let [e, i, n, r] = t;
            return eI(e, i, n, r);
          }
          return "string" == typeof t
            ? ((0, t6.k)(void 0 !== eJ[t], `Invalid easing type '${t}'`), eJ[t])
            : t;
        };
      var e0 = i(2548),
        e1 = i(839);
      function e2({
        duration: t = 300,
        keyframes: e,
        times: i,
        ease: n = "easeInOut",
      }) {
        let r = ez(n) ? n.map(eQ) : eQ(n),
          o = { done: !1, value: e[0] },
          s = (i && i.length === e.length ? i : (0, e1.Y)(e)).map((e) => e * t),
          a = (0, e0.s)(s, e, {
            ease: Array.isArray(r)
              ? r
              : e.map(() => r || eN).splice(0, e.length - 1),
          });
        return {
          calculatedDuration: t,
          next: (e) => ((o.value = a(e)), (o.done = e >= t), o),
        };
      }
      var e5 = i(5389);
      let e3 = (t) => {
          let e = ({ timestamp: e }) => t(e);
          return {
            start: () => tm.Wi.update(e, !0),
            stop: () => (0, tm.Pn)(e),
            now: () =>
              tm.frameData.isProcessing ? tm.frameData.timestamp : t5.X.now(),
          };
        },
        e6 = { decay: eF, inertia: eF, tween: e2, keyframes: e2, spring: eL },
        e4 = (t) => t / 100;
      class e9 extends eR {
        constructor({ KeyframeResolver: t = ep, ...e }) {
          super(e),
            (this.holdTime = null),
            (this.startTime = null),
            (this.cancelTime = null),
            (this.currentTime = 0),
            (this.playbackSpeed = 1),
            (this.pendingPlayState = "running"),
            (this.state = "idle"),
            (this.stop = () => {
              if (
                (this.resolver.cancel(),
                (this.isStopped = !0),
                "idle" === this.state)
              )
                return;
              this.teardown();
              let { onStop: t } = this.options;
              t && t();
            });
          let { name: i, motionValue: n, keyframes: r } = this.options,
            o = (t, e) => this.onKeyframesResolved(t, e);
          i && n && n.owner
            ? (this.resolver = n.owner.resolveKeyframes(r, o, i, n))
            : (this.resolver = new t(r, o, i, n)),
            this.resolver.scheduleResolve();
        }
        initPlayback(t) {
          let e, i;
          let {
              type: n = "keyframes",
              repeat: r = 0,
              repeatDelay: o = 0,
              repeatType: s,
              velocity: a = 0,
            } = this.options,
            l = e6[n] || e2;
          l !== e2 &&
            "number" != typeof t[0] &&
            ((e = (0, tP.z)(e4, (0, e5.C)(t[0], t[1]))), (t = [0, 100]));
          let u = l({ ...this.options, keyframes: t });
          "mirror" === s &&
            (i = l({
              ...this.options,
              keyframes: [...t].reverse(),
              velocity: -a,
            })),
            null === u.calculatedDuration &&
              (u.calculatedDuration = (function (t) {
                let e = 0,
                  i = t.next(e);
                for (; !i.done && e < 2e4; ) (e += 50), (i = t.next(e));
                return e >= 2e4 ? 1 / 0 : e;
              })(u));
          let { calculatedDuration: c } = u,
            h = c + o;
          return {
            generator: u,
            mirroredGenerator: i,
            mapPercentToKeyframes: e,
            calculatedDuration: c,
            resolvedDuration: h,
            totalDuration: h * (r + 1) - o,
          };
        }
        onPostResolved() {
          let { autoplay: t = !0 } = this.options;
          this.play(),
            "paused" !== this.pendingPlayState && t
              ? (this.state = this.pendingPlayState)
              : this.pause();
        }
        tick(t, e = !1) {
          let { resolved: i } = this;
          if (!i) {
            let { keyframes: t } = this.options;
            return { done: !0, value: t[t.length - 1] };
          }
          let {
            finalKeyframe: n,
            generator: r,
            mirroredGenerator: o,
            mapPercentToKeyframes: s,
            keyframes: a,
            calculatedDuration: l,
            totalDuration: u,
            resolvedDuration: c,
          } = i;
          if (null === this.startTime) return r.next(0);
          let {
            delay: h,
            repeat: d,
            repeatType: p,
            repeatDelay: f,
            onUpdate: m,
          } = this.options;
          this.speed > 0
            ? (this.startTime = Math.min(this.startTime, t))
            : this.speed < 0 &&
              (this.startTime = Math.min(t - u / this.speed, this.startTime)),
            e
              ? (this.currentTime = t)
              : null !== this.holdTime
              ? (this.currentTime = this.holdTime)
              : (this.currentTime =
                  Math.round(t - this.startTime) * this.speed);
          let v = this.currentTime - h * (this.speed >= 0 ? 1 : -1),
            y = this.speed >= 0 ? v < 0 : v > u;
          (this.currentTime = Math.max(v, 0)),
            "finished" === this.state &&
              null === this.holdTime &&
              (this.currentTime = u);
          let g = this.currentTime,
            x = r;
          if (d) {
            let t = Math.min(this.currentTime, u) / c,
              e = Math.floor(t),
              i = t % 1;
            !i && t >= 1 && (i = 1),
              1 === i && e--,
              (e = Math.min(e, d + 1)) % 2 &&
                ("reverse" === p
                  ? ((i = 1 - i), f && (i -= f / c))
                  : "mirror" === p && (x = o)),
              (g = (0, eO.u)(0, 1, i) * c);
          }
          let w = y ? { done: !1, value: a[0] } : x.next(g);
          s && (w.value = s(w.value));
          let { done: b } = w;
          y ||
            null === l ||
            (b =
              this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
          let S =
            null === this.holdTime &&
            ("finished" === this.state || ("running" === this.state && b));
          return (
            S && void 0 !== n && (w.value = t2(a, this.options, n)),
            m && m(w.value),
            S && this.finish(),
            w
          );
        }
        get duration() {
          let { resolved: t } = this;
          return t ? tX(t.calculatedDuration) : 0;
        }
        get time() {
          return tX(this.currentTime);
        }
        set time(t) {
          (t = tH(t)),
            (this.currentTime = t),
            null !== this.holdTime || 0 === this.speed
              ? (this.holdTime = t)
              : this.driver &&
                (this.startTime = this.driver.now() - t / this.speed);
        }
        get speed() {
          return this.playbackSpeed;
        }
        set speed(t) {
          let e = this.playbackSpeed !== t;
          (this.playbackSpeed = t), e && (this.time = tX(this.currentTime));
        }
        play() {
          if (
            (this.resolver.isScheduled || this.resolver.resume(),
            !this._resolved)
          ) {
            this.pendingPlayState = "running";
            return;
          }
          if (this.isStopped) return;
          let { driver: t = e3, onPlay: e } = this.options;
          this.driver || (this.driver = t((t) => this.tick(t))), e && e();
          let i = this.driver.now();
          null !== this.holdTime
            ? (this.startTime = i - this.holdTime)
            : (this.startTime && "finished" !== this.state) ||
              (this.startTime = i),
            "finished" === this.state && this.updateFinishedPromise(),
            (this.cancelTime = this.startTime),
            (this.holdTime = null),
            (this.state = "running"),
            this.driver.start();
        }
        pause() {
          var t;
          if (!this._resolved) {
            this.pendingPlayState = "paused";
            return;
          }
          (this.state = "paused"),
            (this.holdTime =
              null !== (t = this.currentTime) && void 0 !== t ? t : 0);
        }
        complete() {
          "running" !== this.state && this.play(),
            (this.pendingPlayState = this.state = "finished"),
            (this.holdTime = null);
        }
        finish() {
          this.teardown(), (this.state = "finished");
          let { onComplete: t } = this.options;
          t && t();
        }
        cancel() {
          null !== this.cancelTime && this.tick(this.cancelTime),
            this.teardown(),
            this.updateFinishedPromise();
        }
        teardown() {
          (this.state = "idle"),
            this.stopDriver(),
            this.resolveFinishedPromise(),
            this.updateFinishedPromise(),
            (this.startTime = this.cancelTime = null),
            this.resolver.cancel();
        }
        stopDriver() {
          this.driver && (this.driver.stop(), (this.driver = void 0));
        }
        sample(t) {
          return (this.startTime = 0), this.tick(t, !0);
        }
      }
      let e8 = (t) => Array.isArray(t) && "number" == typeof t[0],
        e7 = ([t, e, i, n]) => `cubic-bezier(${t}, ${e}, ${i}, ${n})`,
        it = {
          linear: "linear",
          ease: "ease",
          easeIn: "ease-in",
          easeOut: "ease-out",
          easeInOut: "ease-in-out",
          circIn: e7([0, 0.65, 0.55, 1]),
          circOut: e7([0.55, 0, 1, 0.45]),
          backIn: e7([0.31, 0.01, 0.66, -0.59]),
          backOut: e7([0.33, 1.53, 0.69, 0.99]),
        };
      function ie(t) {
        return ii(t) || it.easeOut;
      }
      function ii(t) {
        if (t) return e8(t) ? e7(t) : Array.isArray(t) ? t.map(ie) : it[t];
      }
      let ir = eE(() =>
          Object.hasOwnProperty.call(Element.prototype, "animate")
        ),
        io = new Set(["opacity", "clipPath", "filter", "transform"]);
      class is extends eR {
        constructor(t) {
          super(t);
          let { name: e, motionValue: i, keyframes: n } = this.options;
          (this.resolver = new eA(
            n,
            (t, e) => this.onKeyframesResolved(t, e),
            e,
            i
          )),
            this.resolver.scheduleResolve();
        }
        initPlayback(t, e) {
          var i, n;
          let {
            duration: r = 300,
            times: o,
            ease: s,
            type: a,
            motionValue: l,
            name: u,
          } = this.options;
          if (!(null === (i = l.owner) || void 0 === i ? void 0 : i.current))
            return !1;
          if (
            "spring" === (n = this.options).type ||
            "backgroundColor" === n.name ||
            !(function t(e) {
              return !!(
                !e ||
                ("string" == typeof e && e in it) ||
                e8(e) ||
                (Array.isArray(e) && e.every(t))
              );
            })(n.ease)
          ) {
            let {
                onComplete: e,
                onUpdate: i,
                motionValue: n,
                ...l
              } = this.options,
              u = (function (t, e) {
                let i = new e9({
                    ...e,
                    keyframes: t,
                    repeat: 0,
                    delay: 0,
                    isGenerator: !0,
                  }),
                  n = { done: !1, value: t[0] },
                  r = [],
                  o = 0;
                for (; !n.done && o < 2e4; )
                  r.push((n = i.sample(o)).value), (o += 10);
                return {
                  times: void 0,
                  keyframes: r,
                  duration: o - 10,
                  ease: "linear",
                };
              })(t, l);
            1 === (t = u.keyframes).length && (t[1] = t[0]),
              (r = u.duration),
              (o = u.times),
              (s = u.ease),
              (a = "keyframes");
          }
          let c = (function (
            t,
            e,
            i,
            {
              delay: n = 0,
              duration: r = 300,
              repeat: o = 0,
              repeatType: s = "loop",
              ease: a,
              times: l,
            } = {}
          ) {
            let u = { [e]: i };
            l && (u.offset = l);
            let c = ii(a);
            return (
              Array.isArray(c) && (u.easing = c),
              t.animate(u, {
                delay: n,
                duration: r,
                easing: Array.isArray(c) ? "linear" : c,
                fill: "both",
                iterations: o + 1,
                direction: "reverse" === s ? "alternate" : "normal",
              })
            );
          })(l.owner.current, u, t, {
            ...this.options,
            duration: r,
            times: o,
            ease: s,
          });
          return (
            (c.startTime = t5.X.now()),
            this.pendingTimeline
              ? ((c.timeline = this.pendingTimeline),
                (this.pendingTimeline = void 0))
              : (c.onfinish = () => {
                  let { onComplete: i } = this.options;
                  l.set(t2(t, this.options, e)),
                    i && i(),
                    this.cancel(),
                    this.resolveFinishedPromise();
                }),
            {
              animation: c,
              duration: r,
              times: o,
              type: a,
              ease: s,
              keyframes: t,
            }
          );
        }
        get duration() {
          let { resolved: t } = this;
          if (!t) return 0;
          let { duration: e } = t;
          return tX(e);
        }
        get time() {
          let { resolved: t } = this;
          if (!t) return 0;
          let { animation: e } = t;
          return tX(e.currentTime || 0);
        }
        set time(t) {
          let { resolved: e } = this;
          if (!e) return;
          let { animation: i } = e;
          i.currentTime = tH(t);
        }
        get speed() {
          let { resolved: t } = this;
          if (!t) return 1;
          let { animation: e } = t;
          return e.playbackRate;
        }
        set speed(t) {
          let { resolved: e } = this;
          if (!e) return;
          let { animation: i } = e;
          i.playbackRate = t;
        }
        get state() {
          let { resolved: t } = this;
          if (!t) return "idle";
          let { animation: e } = t;
          return e.playState;
        }
        attachTimeline(t) {
          if (this._resolved) {
            let { resolved: e } = this;
            if (!e) return tj.Z;
            let { animation: i } = e;
            (i.timeline = t), (i.onfinish = null);
          } else this.pendingTimeline = t;
          return tj.Z;
        }
        play() {
          if (this.isStopped) return;
          let { resolved: t } = this;
          if (!t) return;
          let { animation: e } = t;
          "finished" === e.playState && this.updateFinishedPromise(), e.play();
        }
        pause() {
          let { resolved: t } = this;
          if (!t) return;
          let { animation: e } = t;
          e.pause();
        }
        stop() {
          if (
            (this.resolver.cancel(),
            (this.isStopped = !0),
            "idle" === this.state)
          )
            return;
          let { resolved: t } = this;
          if (!t) return;
          let {
            animation: e,
            keyframes: i,
            duration: n,
            type: r,
            ease: o,
            times: s,
          } = t;
          if ("idle" !== e.playState && "finished" !== e.playState) {
            if (this.time) {
              let {
                  motionValue: t,
                  onUpdate: e,
                  onComplete: a,
                  ...l
                } = this.options,
                u = new e9({
                  ...l,
                  keyframes: i,
                  duration: n,
                  type: r,
                  ease: o,
                  times: s,
                  isGenerator: !0,
                }),
                c = tH(this.time);
              t.setWithVelocity(u.sample(c - 10).value, u.sample(c).value, 10);
            }
            this.cancel();
          }
        }
        complete() {
          let { resolved: t } = this;
          t && t.animation.finish();
        }
        cancel() {
          let { resolved: t } = this;
          t && t.animation.cancel();
        }
        static supports(t) {
          let {
            motionValue: e,
            name: i,
            repeatDelay: n,
            repeatType: r,
            damping: o,
            type: s,
          } = t;
          return (
            ir() &&
            i &&
            io.has(i) &&
            e &&
            e.owner &&
            e.owner.current instanceof HTMLElement &&
            !e.owner.getProps().onUpdate &&
            !n &&
            "mirror" !== r &&
            0 !== o &&
            "inertia" !== s
          );
        }
      }
      let ia = eE(() => void 0 !== window.ScrollTimeline);
      class il {
        constructor(t) {
          (this.stop = () => this.runAll("stop")),
            (this.animations = t.filter(Boolean));
        }
        then(t, e) {
          return Promise.all(this.animations).then(t).catch(e);
        }
        getAll(t) {
          return this.animations[0][t];
        }
        setAll(t, e) {
          for (let i = 0; i < this.animations.length; i++)
            this.animations[i][t] = e;
        }
        attachTimeline(t) {
          let e = this.animations.map((e) => {
            if (!ia() || !e.attachTimeline)
              return (
                e.pause(),
                (function (t, e) {
                  let i;
                  let n = () => {
                    let { currentTime: n } = e,
                      r = (null === n ? 0 : n.value) / 100;
                    i !== r && t(r), (i = r);
                  };
                  return tm.Wi.update(n, !0), () => (0, tm.Pn)(n);
                })((t) => {
                  e.time = e.duration * t;
                }, t)
              );
            e.attachTimeline(t);
          });
          return () => {
            e.forEach((t, e) => {
              t && t(), this.animations[e].stop();
            });
          };
        }
        get time() {
          return this.getAll("time");
        }
        set time(t) {
          this.setAll("time", t);
        }
        get speed() {
          return this.getAll("speed");
        }
        set speed(t) {
          this.setAll("speed", t);
        }
        get duration() {
          let t = 0;
          for (let e = 0; e < this.animations.length; e++)
            t = Math.max(t, this.animations[e].duration);
          return t;
        }
        runAll(t) {
          this.animations.forEach((e) => e[t]());
        }
        play() {
          this.runAll("play");
        }
        pause() {
          this.runAll("pause");
        }
        cancel() {
          this.runAll("cancel");
        }
        complete() {
          this.runAll("complete");
        }
      }
      let iu =
        (t, e, i, n = {}, r, o) =>
        (s) => {
          let a = tJ(n, t) || {},
            l = a.delay || n.delay || 0,
            { elapsed: u = 0 } = n;
          u -= tH(l);
          let c = {
            keyframes: Array.isArray(i) ? i : [null, i],
            ease: "easeOut",
            velocity: e.getVelocity(),
            ...a,
            delay: -u,
            onUpdate: (t) => {
              e.set(t), a.onUpdate && a.onUpdate(t);
            },
            onComplete: () => {
              s(), a.onComplete && a.onComplete();
            },
            name: t,
            motionValue: e,
            element: o ? void 0 : r,
          };
          !(function ({
            when: t,
            delay: e,
            delayChildren: i,
            staggerChildren: n,
            staggerDirection: r,
            repeat: o,
            repeatType: s,
            repeatDelay: a,
            from: l,
            elapsed: u,
            ...c
          }) {
            return !!Object.keys(c).length;
          })(a) && (c = { ...c, ...tG(t, c) }),
            c.duration && (c.duration = tH(c.duration)),
            c.repeatDelay && (c.repeatDelay = tH(c.repeatDelay)),
            void 0 !== c.from && (c.keyframes[0] = c.from);
          let h = !1;
          if (
            ((!1 !== c.type && (0 !== c.duration || c.repeatDelay)) ||
              ((c.duration = 0), 0 !== c.delay || (h = !0)),
            (t0.current || tQ.c.skipAnimations) &&
              ((h = !0), (c.duration = 0), (c.delay = 0)),
            h && !o && void 0 !== e.get())
          ) {
            let t = t2(c.keyframes, a);
            if (void 0 !== t)
              return (
                tm.Wi.update(() => {
                  c.onUpdate(t), c.onComplete();
                }),
                new il([])
              );
          }
          return !o && is.supports(c) ? new is(c) : new e9(c);
        };
      function ic(t) {
        return !!(_(t) && t.add);
      }
      var ih = i(804);
      function id(t) {
        return t.getProps()[d];
      }
      function ip(t, e, { delay: i = 0, transitionOverride: n, type: r } = {}) {
        var o;
        let {
            transition: s = t.getDefaultTransition(),
            transitionEnd: a,
            ...l
          } = e,
          u = t.getValue("willChange");
        n && (s = n);
        let c = [],
          h = r && t.animationState && t.animationState.getState()[r];
        for (let e in l) {
          let n = t.getValue(
              e,
              null !== (o = t.latestValues[e]) && void 0 !== o ? o : null
            ),
            r = l[e];
          if (
            void 0 === r ||
            (h &&
              (function ({ protectedKeys: t, needsAnimating: e }, i) {
                let n = t.hasOwnProperty(i) && !0 !== e[i];
                return (e[i] = !1), n;
              })(h, e))
          )
            continue;
          let a = { delay: i, elapsed: 0, ...tJ(s || {}, e) },
            d = !1;
          if (window.HandoffAppearAnimations) {
            let i = id(t);
            if (i) {
              let t = window.HandoffAppearAnimations(i, e, n, tm.Wi);
              null !== t && ((a.elapsed = t), (d = !0));
            }
          }
          n.start(
            iu(
              e,
              n,
              r,
              t.shouldReduceMotion && M.has(e) ? { type: !1 } : a,
              t,
              d
            )
          );
          let p = n.animation;
          p && (ic(u) && (u.add(e), p.then(() => u.remove(e))), c.push(p));
        }
        return (
          a &&
            Promise.all(c).then(() => {
              tm.Wi.update(() => {
                a &&
                  (function (t, e) {
                    let {
                      transitionEnd: i = {},
                      transition: n = {},
                      ...r
                    } = tU(t, e) || {};
                    for (let e in (r = { ...r, ...i })) {
                      let i = td(r[e]);
                      t.hasValue(e)
                        ? t.getValue(e).set(i)
                        : t.addValue(e, (0, ih.BX)(i));
                    }
                  })(t, a);
              });
            }),
          c
        );
      }
      function im(t, e, i = {}) {
        var n;
        let r = tU(
            t,
            e,
            "exit" === i.type
              ? null === (n = t.presenceContext) || void 0 === n
                ? void 0
                : n.custom
              : void 0
          ),
          { transition: o = t.getDefaultTransition() || {} } = r || {};
        i.transitionOverride && (o = i.transitionOverride);
        let s = r ? () => Promise.all(ip(t, r, i)) : () => Promise.resolve(),
          a =
            t.variantChildren && t.variantChildren.size
              ? (n = 0) => {
                  let {
                    delayChildren: r = 0,
                    staggerChildren: s,
                    staggerDirection: a,
                  } = o;
                  return (function (t, e, i = 0, n = 0, r = 1, o) {
                    let s = [],
                      a = (t.variantChildren.size - 1) * n,
                      l = 1 === r ? (t = 0) => t * n : (t = 0) => a - t * n;
                    return (
                      Array.from(t.variantChildren)
                        .sort(iv)
                        .forEach((t, n) => {
                          t.notify("AnimationStart", e),
                            s.push(
                              im(t, e, { ...o, delay: i + l(n) }).then(() =>
                                t.notify("AnimationComplete", e)
                              )
                            );
                        }),
                      Promise.all(s)
                    );
                  })(t, e, r + n, s, a, i);
                }
              : () => Promise.resolve(),
          { when: l } = o;
        if (!l) return Promise.all([s(), a(i.delay)]);
        {
          let [t, e] = "beforeChildren" === l ? [s, a] : [a, s];
          return t().then(() => e());
        }
      }
      function iv(t, e) {
        return t.sortNodePosition(e);
      }
      let iy = [...g].reverse(),
        ig = g.length;
      function ix(t = !1) {
        return {
          isActive: t,
          protectedKeys: {},
          needsAnimating: {},
          prevResolvedValues: {},
        };
      }
      class iw extends tk {
        constructor(t) {
          super(t),
            t.animationState ||
              (t.animationState = (function (t) {
                let e = (e) =>
                    Promise.all(
                      e.map(({ animation: e, options: i }) =>
                        (function (t, e, i = {}) {
                          let n;
                          if ((t.notify("AnimationStart", e), Array.isArray(e)))
                            n = Promise.all(e.map((e) => im(t, e, i)));
                          else if ("string" == typeof e) n = im(t, e, i);
                          else {
                            let r =
                              "function" == typeof e ? tU(t, e, i.custom) : e;
                            n = Promise.all(ip(t, r, i));
                          }
                          return n.then(() => {
                            tm.Wi.postRender(() => {
                              t.notify("AnimationComplete", e);
                            });
                          });
                        })(t, e, i)
                      )
                    ),
                  i = {
                    animate: ix(!0),
                    whileInView: ix(),
                    whileHover: ix(),
                    whileTap: ix(),
                    whileDrag: ix(),
                    whileFocus: ix(),
                    exit: ix(),
                  },
                  n = !0,
                  r = (e) => (i, n) => {
                    var r;
                    let o = tU(
                      t,
                      n,
                      "exit" === e
                        ? null === (r = t.presenceContext) || void 0 === r
                          ? void 0
                          : r.custom
                        : void 0
                    );
                    if (o) {
                      let { transition: t, transitionEnd: e, ...n } = o;
                      i = { ...i, ...n, ...e };
                    }
                    return i;
                  };
                function o(o) {
                  let s = t.getProps(),
                    a = t.getVariantContext(!0) || {},
                    l = [],
                    u = new Set(),
                    c = {},
                    h = 1 / 0;
                  for (let e = 0; e < ig; e++) {
                    var d;
                    let p = iy[e],
                      f = i[p],
                      m = void 0 !== s[p] ? s[p] : a[p],
                      g = v(m),
                      x = p === o ? f.isActive : null;
                    !1 === x && (h = e);
                    let w = m === a[p] && m !== s[p] && g;
                    if (
                      (w && n && t.manuallyAnimateOnMount && (w = !1),
                      (f.protectedKeys = { ...c }),
                      (!f.isActive && null === x) ||
                        (!m && !f.prevProp) ||
                        y(m) ||
                        "boolean" == typeof m)
                    )
                      continue;
                    let b =
                        ((d = f.prevProp),
                        ("string" == typeof m
                          ? m !== d
                          : !!Array.isArray(m) && !tz(m, d)) ||
                          (p === o && f.isActive && !w && g) ||
                          (e > h && g)),
                      S = !1,
                      P = Array.isArray(m) ? m : [m],
                      T = P.reduce(r(p), {});
                    !1 === x && (T = {});
                    let { prevResolvedValues: A = {} } = f,
                      E = { ...A, ...T },
                      C = (e) => {
                        (b = !0),
                          u.has(e) && ((S = !0), u.delete(e)),
                          (f.needsAnimating[e] = !0);
                        let i = t.getValue(e);
                        i && (i.liveStyle = !1);
                      };
                    for (let t in E) {
                      let e = T[t],
                        i = A[t];
                      if (!c.hasOwnProperty(t))
                        (tc(e) && tc(i) ? tz(e, i) : e === i)
                          ? void 0 !== e && u.has(t)
                            ? C(t)
                            : (f.protectedKeys[t] = !0)
                          : null != e
                          ? C(t)
                          : u.add(t);
                    }
                    (f.prevProp = m),
                      (f.prevResolvedValues = T),
                      f.isActive && (c = { ...c, ...T }),
                      n && t.blockInitialAnimation && (b = !1),
                      b &&
                        (!w || S) &&
                        l.push(
                          ...P.map((t) => ({
                            animation: t,
                            options: { type: p },
                          }))
                        );
                  }
                  if (u.size) {
                    let e = {};
                    u.forEach((i) => {
                      let n = t.getBaseTarget(i),
                        r = t.getValue(i);
                      r && (r.liveStyle = !0), (e[i] = null != n ? n : null);
                    }),
                      l.push({ animation: e });
                  }
                  let p = !!l.length;
                  return (
                    n &&
                      (!1 === s.initial || s.initial === s.animate) &&
                      !t.manuallyAnimateOnMount &&
                      (p = !1),
                    (n = !1),
                    p ? e(l) : Promise.resolve()
                  );
                }
                return {
                  animateChanges: o,
                  setActive: function (e, n) {
                    var r;
                    if (i[e].isActive === n) return Promise.resolve();
                    null === (r = t.variantChildren) ||
                      void 0 === r ||
                      r.forEach((t) => {
                        var i;
                        return null === (i = t.animationState) || void 0 === i
                          ? void 0
                          : i.setActive(e, n);
                      }),
                      (i[e].isActive = n);
                    let s = o(e);
                    for (let t in i) i[t].protectedKeys = {};
                    return s;
                  },
                  setAnimateFunction: function (i) {
                    e = i(t);
                  },
                  getState: () => i,
                };
              })(t));
        }
        updateAnimationControlsSubscription() {
          let { animate: t } = this.node.getProps();
          this.unmount(), y(t) && (this.unmount = t.subscribe(this.node));
        }
        mount() {
          this.updateAnimationControlsSubscription();
        }
        update() {
          let { animate: t } = this.node.getProps(),
            { animate: e } = this.node.prevProps || {};
          t !== e && this.updateAnimationControlsSubscription();
        }
        unmount() {}
      }
      let ib = 0;
      class iS extends tk {
        constructor() {
          super(...arguments), (this.id = ib++);
        }
        update() {
          if (!this.node.presenceContext) return;
          let { isPresent: t, onExitComplete: e } = this.node.presenceContext,
            { isPresent: i } = this.node.prevPresenceContext || {};
          if (!this.node.animationState || t === i) return;
          let n = this.node.animationState.setActive("exit", !t);
          e && !t && n.then(() => e(this.id));
        }
        mount() {
          let { register: t } = this.node.presenceContext || {};
          t && (this.unmount = t(this.id));
        }
        unmount() {}
      }
      let iP = (t, e) => Math.abs(t - e);
      class iT {
        constructor(
          t,
          e,
          {
            transformPagePoint: i,
            contextWindow: n,
            dragSnapToOrigin: r = !1,
          } = {}
        ) {
          if (
            ((this.startEvent = null),
            (this.lastMoveEvent = null),
            (this.lastMoveEventInfo = null),
            (this.handlers = {}),
            (this.contextWindow = window),
            (this.updatePoint = () => {
              var t, e;
              if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
              let i = iC(this.lastMoveEventInfo, this.history),
                n = null !== this.startEvent,
                r =
                  ((t = i.offset),
                  (e = { x: 0, y: 0 }),
                  Math.sqrt(iP(t.x, e.x) ** 2 + iP(t.y, e.y) ** 2) >= 3);
              if (!n && !r) return;
              let { point: o } = i,
                { timestamp: s } = tm.frameData;
              this.history.push({ ...o, timestamp: s });
              let { onStart: a, onMove: l } = this.handlers;
              n ||
                (a && a(this.lastMoveEvent, i),
                (this.startEvent = this.lastMoveEvent)),
                l && l(this.lastMoveEvent, i);
            }),
            (this.handlePointerMove = (t, e) => {
              (this.lastMoveEvent = t),
                (this.lastMoveEventInfo = iA(e, this.transformPagePoint)),
                tm.Wi.update(this.updatePoint, !0);
            }),
            (this.handlePointerUp = (t, e) => {
              this.end();
              let {
                onEnd: i,
                onSessionEnd: n,
                resumeAnimation: r,
              } = this.handlers;
              if (
                (this.dragSnapToOrigin && r && r(),
                !(this.lastMoveEvent && this.lastMoveEventInfo))
              )
                return;
              let o = iC(
                "pointercancel" === t.type
                  ? this.lastMoveEventInfo
                  : iA(e, this.transformPagePoint),
                this.history
              );
              this.startEvent && i && i(t, o), n && n(t, o);
            }),
            !tx(t))
          )
            return;
          (this.dragSnapToOrigin = r),
            (this.handlers = e),
            (this.transformPagePoint = i),
            (this.contextWindow = n || window);
          let o = iA(tw(t), this.transformPagePoint),
            { point: s } = o,
            { timestamp: a } = tm.frameData;
          this.history = [{ ...s, timestamp: a }];
          let { onSessionStart: l } = e;
          l && l(t, iC(o, this.history)),
            (this.removeListeners = (0, tP.z)(
              tS(this.contextWindow, "pointermove", this.handlePointerMove),
              tS(this.contextWindow, "pointerup", this.handlePointerUp),
              tS(this.contextWindow, "pointercancel", this.handlePointerUp)
            ));
        }
        updateHandlers(t) {
          this.handlers = t;
        }
        end() {
          this.removeListeners && this.removeListeners(),
            (0, tm.Pn)(this.updatePoint);
        }
      }
      function iA(t, e) {
        return e ? { point: e(t.point) } : t;
      }
      function iE(t, e) {
        return { x: t.x - e.x, y: t.y - e.y };
      }
      function iC({ point: t }, e) {
        return {
          point: t,
          delta: iE(t, iR(e)),
          offset: iE(t, e[0]),
          velocity: (function (t, e) {
            if (t.length < 2) return { x: 0, y: 0 };
            let i = t.length - 1,
              n = null,
              r = iR(t);
            for (
              ;
              i >= 0 && ((n = t[i]), !(r.timestamp - n.timestamp > tH(0.1)));

            )
              i--;
            if (!n) return { x: 0, y: 0 };
            let o = tX(r.timestamp - n.timestamp);
            if (0 === o) return { x: 0, y: 0 };
            let s = { x: (r.x - n.x) / o, y: (r.y - n.y) / o };
            return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
          })(e, 0),
        };
      }
      function iR(t) {
        return t[t.length - 1];
      }
      var ik = i(3217),
        iV = i(5004);
      function iO(t) {
        return t.max - t.min;
      }
      function iD(t, e = 0, i = 0.01) {
        return Math.abs(t - e) <= i;
      }
      function iM(t, e, i, n = 0.5) {
        (t.origin = n),
          (t.originPoint = (0, iV.t)(e.min, e.max, t.origin)),
          (t.scale = iO(i) / iO(e)),
          (iD(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1),
          (t.translate = (0, iV.t)(i.min, i.max, t.origin) - t.originPoint),
          (iD(t.translate) || isNaN(t.translate)) && (t.translate = 0);
      }
      function ij(t, e, i, n) {
        iM(t.x, e.x, i.x, n ? n.originX : void 0),
          iM(t.y, e.y, i.y, n ? n.originY : void 0);
      }
      function i_(t, e, i) {
        (t.min = i.min + e.min), (t.max = t.min + iO(e));
      }
      function iL(t, e, i) {
        (t.min = e.min - i.min), (t.max = t.min + iO(e));
      }
      function iF(t, e, i) {
        iL(t.x, e.x, i.x), iL(t.y, e.y, i.y);
      }
      function iB(t, e, i) {
        return {
          min: void 0 !== e ? t.min + e : void 0,
          max: void 0 !== i ? t.max + i - (t.max - t.min) : void 0,
        };
      }
      function iI(t, e) {
        let i = e.min - t.min,
          n = e.max - t.max;
        return (
          e.max - e.min < t.max - t.min && ([i, n] = [n, i]), { min: i, max: n }
        );
      }
      function i$(t, e, i) {
        return { min: iW(t, e), max: iW(t, i) };
      }
      function iW(t, e) {
        return "number" == typeof t ? t : t[e] || 0;
      }
      let iN = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
        iz = () => ({ x: iN(), y: iN() }),
        iU = () => ({ min: 0, max: 0 }),
        iH = () => ({ x: iU(), y: iU() });
      function iX(t) {
        return [t("x"), t("y")];
      }
      function iK({ top: t, left: e, right: i, bottom: n }) {
        return { x: { min: e, max: i }, y: { min: t, max: n } };
      }
      function iY(t) {
        return void 0 === t || 1 === t;
      }
      function iq({ scale: t, scaleX: e, scaleY: i }) {
        return !iY(t) || !iY(e) || !iY(i);
      }
      function iZ(t) {
        return (
          iq(t) ||
          iG(t) ||
          t.z ||
          t.rotate ||
          t.rotateX ||
          t.rotateY ||
          t.skewX ||
          t.skewY
        );
      }
      function iG(t) {
        var e, i;
        return ((e = t.x) && "0%" !== e) || ((i = t.y) && "0%" !== i);
      }
      function iJ(t, e, i, n, r) {
        return void 0 !== r && (t = n + r * (t - n)), n + i * (t - n) + e;
      }
      function iQ(t, e = 0, i = 1, n, r) {
        (t.min = iJ(t.min, e, i, n, r)), (t.max = iJ(t.max, e, i, n, r));
      }
      function i0(t, { x: e, y: i }) {
        iQ(t.x, e.translate, e.scale, e.originPoint),
          iQ(t.y, i.translate, i.scale, i.originPoint);
      }
      function i1(t) {
        return Number.isInteger(t)
          ? t
          : t > 1.0000000000001 || t < 0.999999999999
          ? t
          : 1;
      }
      function i2(t, e) {
        (t.min = t.min + e), (t.max = t.max + e);
      }
      function i5(t, e, [i, n, r]) {
        let o = void 0 !== e[r] ? e[r] : 0.5,
          s = (0, iV.t)(t.min, t.max, o);
        iQ(t, e[i], e[n], s, e.scale);
      }
      let i3 = ["x", "scaleX", "originX"],
        i6 = ["y", "scaleY", "originY"];
      function i4(t, e) {
        i5(t.x, e, i3), i5(t.y, e, i6);
      }
      function i9(t, e) {
        return iK(
          (function (t, e) {
            if (!e) return t;
            let i = e({ x: t.left, y: t.top }),
              n = e({ x: t.right, y: t.bottom });
            return { top: i.y, left: i.x, bottom: n.y, right: n.x };
          })(t.getBoundingClientRect(), e)
        );
      }
      let i8 = ({ current: t }) => (t ? t.ownerDocument.defaultView : null),
        i7 = new WeakMap();
      class nt {
        constructor(t) {
          (this.openGlobalLock = null),
            (this.isDragging = !1),
            (this.currentDirection = null),
            (this.originPoint = { x: 0, y: 0 }),
            (this.constraints = !1),
            (this.hasMutatedConstraints = !1),
            (this.elastic = iH()),
            (this.visualElement = t);
        }
        start(t, { snapToCursor: e = !1 } = {}) {
          let { presenceContext: i } = this.visualElement;
          if (i && !1 === i.isPresent) return;
          let { dragSnapToOrigin: n } = this.getProps();
          this.panSession = new iT(
            t,
            {
              onSessionStart: (t) => {
                let { dragSnapToOrigin: i } = this.getProps();
                i ? this.pauseAnimation() : this.stopAnimation(),
                  e && this.snapToCursor(tw(t, "page").point);
              },
              onStart: (t, e) => {
                let {
                  drag: i,
                  dragPropagation: n,
                  onDragStart: r,
                } = this.getProps();
                if (
                  i &&
                  !n &&
                  (this.openGlobalLock && this.openGlobalLock(),
                  (this.openGlobalLock = tC(i)),
                  !this.openGlobalLock)
                )
                  return;
                (this.isDragging = !0),
                  (this.currentDirection = null),
                  this.resolveConstraints(),
                  this.visualElement.projection &&
                    ((this.visualElement.projection.isAnimationBlocked = !0),
                    (this.visualElement.projection.target = void 0)),
                  iX((t) => {
                    let e = this.getAxisMotionValue(t).get() || 0;
                    if (W.aQ.test(e)) {
                      let { projection: i } = this.visualElement;
                      if (i && i.layout) {
                        let n = i.layout.layoutBox[t];
                        if (n) {
                          let t = iO(n);
                          e = (parseFloat(e) / 100) * t;
                        }
                      }
                    }
                    this.originPoint[t] = e;
                  }),
                  r && tm.Wi.postRender(() => r(t, e));
                let { animationState: o } = this.visualElement;
                o && o.setActive("whileDrag", !0);
              },
              onMove: (t, e) => {
                let {
                  dragPropagation: i,
                  dragDirectionLock: n,
                  onDirectionLock: r,
                  onDrag: o,
                } = this.getProps();
                if (!i && !this.openGlobalLock) return;
                let { offset: s } = e;
                if (n && null === this.currentDirection) {
                  (this.currentDirection = (function (t, e = 10) {
                    let i = null;
                    return (
                      Math.abs(t.y) > e
                        ? (i = "y")
                        : Math.abs(t.x) > e && (i = "x"),
                      i
                    );
                  })(s)),
                    null !== this.currentDirection &&
                      r &&
                      r(this.currentDirection);
                  return;
                }
                this.updateAxis("x", e.point, s),
                  this.updateAxis("y", e.point, s),
                  this.visualElement.render(),
                  o && o(t, e);
              },
              onSessionEnd: (t, e) => this.stop(t, e),
              resumeAnimation: () =>
                iX((t) => {
                  var e;
                  return (
                    "paused" === this.getAnimationState(t) &&
                    (null === (e = this.getAxisMotionValue(t).animation) ||
                    void 0 === e
                      ? void 0
                      : e.play())
                  );
                }),
            },
            {
              transformPagePoint: this.visualElement.getTransformPagePoint(),
              dragSnapToOrigin: n,
              contextWindow: i8(this.visualElement),
            }
          );
        }
        stop(t, e) {
          let i = this.isDragging;
          if ((this.cancel(), !i)) return;
          let { velocity: n } = e;
          this.startAnimation(n);
          let { onDragEnd: r } = this.getProps();
          r && tm.Wi.postRender(() => r(t, e));
        }
        cancel() {
          this.isDragging = !1;
          let { projection: t, animationState: e } = this.visualElement;
          t && (t.isAnimationBlocked = !1),
            this.panSession && this.panSession.end(),
            (this.panSession = void 0);
          let { dragPropagation: i } = this.getProps();
          !i &&
            this.openGlobalLock &&
            (this.openGlobalLock(), (this.openGlobalLock = null)),
            e && e.setActive("whileDrag", !1);
        }
        updateAxis(t, e, i) {
          let { drag: n } = this.getProps();
          if (!i || !ne(t, n, this.currentDirection)) return;
          let r = this.getAxisMotionValue(t),
            o = this.originPoint[t] + i[t];
          this.constraints &&
            this.constraints[t] &&
            (o = (function (t, { min: e, max: i }, n) {
              return (
                void 0 !== e && t < e
                  ? (t = n ? (0, iV.t)(e, t, n.min) : Math.max(t, e))
                  : void 0 !== i &&
                    t > i &&
                    (t = n ? (0, iV.t)(i, t, n.max) : Math.min(t, i)),
                t
              );
            })(o, this.constraints[t], this.elastic[t])),
            r.set(o);
        }
        resolveConstraints() {
          var t;
          let { dragConstraints: e, dragElastic: i } = this.getProps(),
            n =
              this.visualElement.projection &&
              !this.visualElement.projection.layout
                ? this.visualElement.projection.measure(!1)
                : null === (t = this.visualElement.projection) || void 0 === t
                ? void 0
                : t.layout,
            r = this.constraints;
          e && m(e)
            ? this.constraints ||
              (this.constraints = this.resolveRefConstraints())
            : e && n
            ? (this.constraints = (function (
                t,
                { top: e, left: i, bottom: n, right: r }
              ) {
                return { x: iB(t.x, i, r), y: iB(t.y, e, n) };
              })(n.layoutBox, e))
            : (this.constraints = !1),
            (this.elastic = (function (t = 0.35) {
              return (
                !1 === t ? (t = 0) : !0 === t && (t = 0.35),
                { x: i$(t, "left", "right"), y: i$(t, "top", "bottom") }
              );
            })(i)),
            r !== this.constraints &&
              n &&
              this.constraints &&
              !this.hasMutatedConstraints &&
              iX((t) => {
                !1 !== this.constraints &&
                  this.getAxisMotionValue(t) &&
                  (this.constraints[t] = (function (t, e) {
                    let i = {};
                    return (
                      void 0 !== e.min && (i.min = e.min - t.min),
                      void 0 !== e.max && (i.max = e.max - t.min),
                      i
                    );
                  })(n.layoutBox[t], this.constraints[t]));
              });
        }
        resolveRefConstraints() {
          var t;
          let { dragConstraints: e, onMeasureDragConstraints: i } =
            this.getProps();
          if (!e || !m(e)) return !1;
          let n = e.current;
          (0, t6.k)(
            null !== n,
            "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."
          );
          let { projection: r } = this.visualElement;
          if (!r || !r.layout) return !1;
          let o = (function (t, e, i) {
              let n = i9(t, i),
                { scroll: r } = e;
              return r && (i2(n.x, r.offset.x), i2(n.y, r.offset.y)), n;
            })(n, r.root, this.visualElement.getTransformPagePoint()),
            s = { x: iI((t = r.layout.layoutBox).x, o.x), y: iI(t.y, o.y) };
          if (i) {
            let t = i(
              (function ({ x: t, y: e }) {
                return { top: e.min, right: t.max, bottom: e.max, left: t.min };
              })(s)
            );
            (this.hasMutatedConstraints = !!t), t && (s = iK(t));
          }
          return s;
        }
        startAnimation(t) {
          let {
              drag: e,
              dragMomentum: i,
              dragElastic: n,
              dragTransition: r,
              dragSnapToOrigin: o,
              onDragTransitionEnd: s,
            } = this.getProps(),
            a = this.constraints || {};
          return Promise.all(
            iX((s) => {
              if (!ne(s, e, this.currentDirection)) return;
              let l = (a && a[s]) || {};
              o && (l = { min: 0, max: 0 });
              let u = {
                type: "inertia",
                velocity: i ? t[s] : 0,
                bounceStiffness: n ? 200 : 1e6,
                bounceDamping: n ? 40 : 1e7,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...r,
                ...l,
              };
              return this.startAxisValueAnimation(s, u);
            })
          ).then(s);
        }
        startAxisValueAnimation(t, e) {
          let i = this.getAxisMotionValue(t);
          return i.start(iu(t, i, 0, e, this.visualElement));
        }
        stopAnimation() {
          iX((t) => this.getAxisMotionValue(t).stop());
        }
        pauseAnimation() {
          iX((t) => {
            var e;
            return null === (e = this.getAxisMotionValue(t).animation) ||
              void 0 === e
              ? void 0
              : e.pause();
          });
        }
        getAnimationState(t) {
          var e;
          return null === (e = this.getAxisMotionValue(t).animation) ||
            void 0 === e
            ? void 0
            : e.state;
        }
        getAxisMotionValue(t) {
          let e = `_drag${t.toUpperCase()}`,
            i = this.visualElement.getProps();
          return (
            i[e] ||
            this.visualElement.getValue(
              t,
              (i.initial ? i.initial[t] : void 0) || 0
            )
          );
        }
        snapToCursor(t) {
          iX((e) => {
            let { drag: i } = this.getProps();
            if (!ne(e, i, this.currentDirection)) return;
            let { projection: n } = this.visualElement,
              r = this.getAxisMotionValue(e);
            if (n && n.layout) {
              let { min: i, max: o } = n.layout.layoutBox[e];
              r.set(t[e] - (0, iV.t)(i, o, 0.5));
            }
          });
        }
        scalePositionWithinConstraints() {
          if (!this.visualElement.current) return;
          let { drag: t, dragConstraints: e } = this.getProps(),
            { projection: i } = this.visualElement;
          if (!m(e) || !i || !this.constraints) return;
          this.stopAnimation();
          let n = { x: 0, y: 0 };
          iX((t) => {
            let e = this.getAxisMotionValue(t);
            if (e && !1 !== this.constraints) {
              let i = e.get();
              n[t] = (function (t, e) {
                let i = 0.5,
                  n = iO(t),
                  r = iO(e);
                return (
                  r > n
                    ? (i = (0, ik.Y)(e.min, e.max - n, t.min))
                    : n > r && (i = (0, ik.Y)(t.min, t.max - r, e.min)),
                  (0, eO.u)(0, 1, i)
                );
              })({ min: i, max: i }, this.constraints[t]);
            }
          });
          let { transformTemplate: r } = this.visualElement.getProps();
          (this.visualElement.current.style.transform = r ? r({}, "") : "none"),
            i.root && i.root.updateScroll(),
            i.updateLayout(),
            this.resolveConstraints(),
            iX((e) => {
              if (!ne(e, t, null)) return;
              let i = this.getAxisMotionValue(e),
                { min: r, max: o } = this.constraints[e];
              i.set((0, iV.t)(r, o, n[e]));
            });
        }
        addListeners() {
          if (!this.visualElement.current) return;
          i7.set(this.visualElement, this);
          let t = tS(this.visualElement.current, "pointerdown", (t) => {
              let { drag: e, dragListener: i = !0 } = this.getProps();
              e && i && this.start(t);
            }),
            e = () => {
              let { dragConstraints: t } = this.getProps();
              m(t) && (this.constraints = this.resolveRefConstraints());
            },
            { projection: i } = this.visualElement,
            n = i.addEventListener("measure", e);
          i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()),
            e();
          let r = tg(window, "resize", () =>
              this.scalePositionWithinConstraints()
            ),
            o = i.addEventListener(
              "didUpdate",
              ({ delta: t, hasLayoutChanged: e }) => {
                this.isDragging &&
                  e &&
                  (iX((e) => {
                    let i = this.getAxisMotionValue(e);
                    i &&
                      ((this.originPoint[e] += t[e].translate),
                      i.set(i.get() + t[e].translate));
                  }),
                  this.visualElement.render());
              }
            );
          return () => {
            r(), t(), n(), o && o();
          };
        }
        getProps() {
          let t = this.visualElement.getProps(),
            {
              drag: e = !1,
              dragDirectionLock: i = !1,
              dragPropagation: n = !1,
              dragConstraints: r = !1,
              dragElastic: o = 0.35,
              dragMomentum: s = !0,
            } = t;
          return {
            ...t,
            drag: e,
            dragDirectionLock: i,
            dragPropagation: n,
            dragConstraints: r,
            dragElastic: o,
            dragMomentum: s,
          };
        }
      }
      function ne(t, e, i) {
        return (!0 === e || e === t) && (null === i || i === t);
      }
      class ni extends tk {
        constructor(t) {
          super(t),
            (this.removeGroupControls = tj.Z),
            (this.removeListeners = tj.Z),
            (this.controls = new nt(t));
        }
        mount() {
          let { dragControls: t } = this.node.getProps();
          t && (this.removeGroupControls = t.subscribe(this.controls)),
            (this.removeListeners = this.controls.addListeners() || tj.Z);
        }
        unmount() {
          this.removeGroupControls(), this.removeListeners();
        }
      }
      let nn = (t) => (e, i) => {
        t && tm.Wi.postRender(() => t(e, i));
      };
      class nr extends tk {
        constructor() {
          super(...arguments), (this.removePointerDownListener = tj.Z);
        }
        onPointerDown(t) {
          this.session = new iT(t, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: i8(this.node),
          });
        }
        createPanHandlers() {
          let {
            onPanSessionStart: t,
            onPanStart: e,
            onPan: i,
            onPanEnd: n,
          } = this.node.getProps();
          return {
            onSessionStart: nn(t),
            onStart: nn(e),
            onMove: i,
            onEnd: (t, e) => {
              delete this.session, n && tm.Wi.postRender(() => n(t, e));
            },
          };
        }
        mount() {
          this.removePointerDownListener = tS(
            this.node.current,
            "pointerdown",
            (t) => this.onPointerDown(t)
          );
        }
        update() {
          this.session && this.session.updateHandlers(this.createPanHandlers());
        }
        unmount() {
          this.removePointerDownListener(), this.session && this.session.end();
        }
      }
      let no = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
      function ns(t, e) {
        return e.max === e.min ? 0 : (t / (e.max - e.min)) * 100;
      }
      let na = {
        correct: (t, e) => {
          if (!e.target) return t;
          if ("string" == typeof t) {
            if (!W.px.test(t)) return t;
            t = parseFloat(t);
          }
          let i = ns(t, e.target.x),
            n = ns(t, e.target.y);
          return `${i}% ${n}%`;
        },
      };
      class nl extends o.Component {
        componentDidMount() {
          let {
              visualElement: t,
              layoutGroup: e,
              switchLayoutGroup: i,
              layoutId: n,
            } = this.props,
            { projection: r } = t;
          Object.assign(O, nc),
            r &&
              (e.group && e.group.add(r),
              i && i.register && n && i.register(r),
              r.root.didUpdate(),
              r.addEventListener("animationComplete", () => {
                this.safeToRemove();
              }),
              r.setOptions({
                ...r.options,
                onExitComplete: () => this.safeToRemove(),
              })),
            (no.hasEverUpdated = !0);
        }
        getSnapshotBeforeUpdate(t) {
          let {
              layoutDependency: e,
              visualElement: i,
              drag: n,
              isPresent: r,
            } = this.props,
            o = i.projection;
          return (
            o &&
              ((o.isPresent = r),
              n || t.layoutDependency !== e || void 0 === e
                ? o.willUpdate()
                : this.safeToRemove(),
              t.isPresent === r ||
                (r
                  ? o.promote()
                  : o.relegate() ||
                    tm.Wi.postRender(() => {
                      let t = o.getStack();
                      (t && t.members.length) || this.safeToRemove();
                    }))),
            null
          );
        }
        componentDidUpdate() {
          let { projection: t } = this.props.visualElement;
          t &&
            (t.root.didUpdate(),
            p.postRender(() => {
              !t.currentAnimation && t.isLead() && this.safeToRemove();
            }));
        }
        componentWillUnmount() {
          let {
              visualElement: t,
              layoutGroup: e,
              switchLayoutGroup: i,
            } = this.props,
            { projection: n } = t;
          n &&
            (n.scheduleCheckAfterUnmount(),
            e && e.group && e.group.remove(n),
            i && i.deregister && i.deregister(n));
        }
        safeToRemove() {
          let { safeToRemove: t } = this.props;
          t && t();
        }
        render() {
          return null;
        }
      }
      function nu(t) {
        let [e, i] = (function () {
            let t = (0, o.useContext)(l);
            if (null === t) return [!0, null];
            let { isPresent: e, onExitComplete: i, register: n } = t,
              r = (0, o.useId)();
            return (
              (0, o.useEffect)(() => n(r), []),
              !e && i ? [!1, () => i && i(r)] : [!0]
            );
          })(),
          n = (0, o.useContext)(E);
        return (0, r.jsx)(nl, {
          ...t,
          layoutGroup: n,
          switchLayoutGroup: (0, o.useContext)(C),
          isPresent: e,
          safeToRemove: i,
        });
      }
      let nc = {
        borderRadius: {
          ...na,
          applyTo: [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
          ],
        },
        borderTopLeftRadius: na,
        borderTopRightRadius: na,
        borderBottomLeftRadius: na,
        borderBottomRightRadius: na,
        boxShadow: {
          correct: (t, { treeScale: e, projectionDelta: i }) => {
            let n = ef.P.parse(t);
            if (n.length > 5) return t;
            let r = ef.P.createTransformer(t),
              o = "number" != typeof n[0] ? 1 : 0,
              s = i.x.scale * e.x,
              a = i.y.scale * e.y;
            (n[0 + o] /= s), (n[1 + o] /= a);
            let l = (0, iV.t)(s, a, 0.5);
            return (
              "number" == typeof n[2 + o] && (n[2 + o] /= l),
              "number" == typeof n[3 + o] && (n[3 + o] /= l),
              r(n)
            );
          },
        },
      };
      var nh = i(2428);
      let nd = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
        np = nd.length,
        nf = (t) => ("string" == typeof t ? parseFloat(t) : t),
        nm = (t) => "number" == typeof t || W.px.test(t);
      function nv(t, e) {
        return void 0 !== t[e] ? t[e] : t.borderRadius;
      }
      let ny = nx(0, 0.5, eK),
        ng = nx(0.5, 0.95, tj.Z);
      function nx(t, e, i) {
        return (n) => (n < t ? 0 : n > e ? 1 : i((0, ik.Y)(t, e, n)));
      }
      function nw(t, e) {
        (t.min = e.min), (t.max = e.max);
      }
      function nb(t, e) {
        nw(t.x, e.x), nw(t.y, e.y);
      }
      function nS(t, e, i, n, r) {
        return (
          (t -= e),
          (t = n + (1 / i) * (t - n)),
          void 0 !== r && (t = n + (1 / r) * (t - n)),
          t
        );
      }
      function nP(t, e, [i, n, r], o, s) {
        !(function (t, e = 0, i = 1, n = 0.5, r, o = t, s = t) {
          if (
            (W.aQ.test(e) &&
              ((e = parseFloat(e)),
              (e = (0, iV.t)(s.min, s.max, e / 100) - s.min)),
            "number" != typeof e)
          )
            return;
          let a = (0, iV.t)(o.min, o.max, n);
          t === o && (a -= e),
            (t.min = nS(t.min, e, i, a, r)),
            (t.max = nS(t.max, e, i, a, r));
        })(t, e[i], e[n], e[r], e.scale, o, s);
      }
      let nT = ["x", "scaleX", "originX"],
        nA = ["y", "scaleY", "originY"];
      function nE(t, e, i, n) {
        nP(t.x, e, nT, i ? i.x : void 0, n ? n.x : void 0),
          nP(t.y, e, nA, i ? i.y : void 0, n ? n.y : void 0);
      }
      function nC(t) {
        return 0 === t.translate && 1 === t.scale;
      }
      function nR(t) {
        return nC(t.x) && nC(t.y);
      }
      function nk(t, e) {
        return (
          Math.round(t.x.min) === Math.round(e.x.min) &&
          Math.round(t.x.max) === Math.round(e.x.max) &&
          Math.round(t.y.min) === Math.round(e.y.min) &&
          Math.round(t.y.max) === Math.round(e.y.max)
        );
      }
      function nV(t) {
        return iO(t.x) / iO(t.y);
      }
      var nO = i(8746);
      class nD {
        constructor() {
          this.members = [];
        }
        add(t) {
          (0, nO.y4)(this.members, t), t.scheduleRender();
        }
        remove(t) {
          if (
            ((0, nO.cl)(this.members, t),
            t === this.prevLead && (this.prevLead = void 0),
            t === this.lead)
          ) {
            let t = this.members[this.members.length - 1];
            t && this.promote(t);
          }
        }
        relegate(t) {
          let e;
          let i = this.members.findIndex((e) => t === e);
          if (0 === i) return !1;
          for (let t = i; t >= 0; t--) {
            let i = this.members[t];
            if (!1 !== i.isPresent) {
              e = i;
              break;
            }
          }
          return !!e && (this.promote(e), !0);
        }
        promote(t, e) {
          let i = this.lead;
          if (t !== i && ((this.prevLead = i), (this.lead = t), t.show(), i)) {
            i.instance && i.scheduleRender(),
              t.scheduleRender(),
              (t.resumeFrom = i),
              e && (t.resumeFrom.preserveOpacity = !0),
              i.snapshot &&
                ((t.snapshot = i.snapshot),
                (t.snapshot.latestValues =
                  i.animationValues || i.latestValues)),
              t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
            let { crossfade: n } = t.options;
            !1 === n && i.hide();
          }
        }
        exitAnimationComplete() {
          this.members.forEach((t) => {
            let { options: e, resumingFrom: i } = t;
            e.onExitComplete && e.onExitComplete(),
              i && i.options.onExitComplete && i.options.onExitComplete();
          });
        }
        scheduleRender() {
          this.members.forEach((t) => {
            t.instance && t.scheduleRender(!1);
          });
        }
        removeLeadSnapshot() {
          this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
        }
      }
      function nM(t, e, i) {
        let n = "",
          r = t.x.translate / e.x,
          o = t.y.translate / e.y,
          s = (null == i ? void 0 : i.z) || 0;
        if (
          ((r || o || s) && (n = `translate3d(${r}px, ${o}px, ${s}px) `),
          (1 !== e.x || 1 !== e.y) && (n += `scale(${1 / e.x}, ${1 / e.y}) `),
          i)
        ) {
          let {
            transformPerspective: t,
            rotate: e,
            rotateX: r,
            rotateY: o,
            skewX: s,
            skewY: a,
          } = i;
          t && (n = `perspective(${t}px) ${n}`),
            e && (n += `rotate(${e}deg) `),
            r && (n += `rotateX(${r}deg) `),
            o && (n += `rotateY(${o}deg) `),
            s && (n += `skewX(${s}deg) `),
            a && (n += `skewY(${a}deg) `);
        }
        let a = t.x.scale * e.x,
          l = t.y.scale * e.y;
        return (1 !== a || 1 !== l) && (n += `scale(${a}, ${l})`), n || "none";
      }
      let nj = (t, e) => t.depth - e.depth;
      class n_ {
        constructor() {
          (this.children = []), (this.isDirty = !1);
        }
        add(t) {
          (0, nO.y4)(this.children, t), (this.isDirty = !0);
        }
        remove(t) {
          (0, nO.cl)(this.children, t), (this.isDirty = !0);
        }
        forEach(t) {
          this.isDirty && this.children.sort(nj),
            (this.isDirty = !1),
            this.children.forEach(t);
        }
      }
      let nL = ["", "X", "Y", "Z"],
        nF = { visibility: "hidden" },
        nB = 0,
        nI = {
          type: "projectionFrame",
          totalNodes: 0,
          resolvedTargetDeltas: 0,
          recalculatedProjection: 0,
        };
      function n$(t, e, i, n) {
        let { latestValues: r } = e;
        r[t] && ((i[t] = r[t]), e.setStaticValue(t, 0), n && (n[t] = 0));
      }
      function nW({
        attachResizeListener: t,
        defaultParent: e,
        measureScroll: i,
        checkIsScrollRoot: n,
        resetTransform: r,
      }) {
        return class {
          constructor(t = {}, i = null == e ? void 0 : e()) {
            (this.id = nB++),
              (this.animationId = 0),
              (this.children = new Set()),
              (this.options = {}),
              (this.isTreeAnimating = !1),
              (this.isAnimationBlocked = !1),
              (this.isLayoutDirty = !1),
              (this.isProjectionDirty = !1),
              (this.isSharedProjectionDirty = !1),
              (this.isTransformDirty = !1),
              (this.updateManuallyBlocked = !1),
              (this.updateBlockedByResize = !1),
              (this.isUpdating = !1),
              (this.isSVG = !1),
              (this.needsReset = !1),
              (this.shouldResetTransform = !1),
              (this.hasCheckedOptimisedAppear = !1),
              (this.treeScale = { x: 1, y: 1 }),
              (this.eventHandlers = new Map()),
              (this.hasTreeAnimated = !1),
              (this.updateScheduled = !1),
              (this.projectionUpdateScheduled = !1),
              (this.checkUpdateFailed = () => {
                this.isUpdating &&
                  ((this.isUpdating = !1), this.clearAllSnapshots());
              }),
              (this.updateProjection = () => {
                (this.projectionUpdateScheduled = !1),
                  (nI.totalNodes =
                    nI.resolvedTargetDeltas =
                    nI.recalculatedProjection =
                      0),
                  this.nodes.forEach(nU),
                  this.nodes.forEach(nG),
                  this.nodes.forEach(nJ),
                  this.nodes.forEach(nH),
                  window.MotionDebug && window.MotionDebug.record(nI);
              }),
              (this.hasProjected = !1),
              (this.isVisible = !0),
              (this.animationProgress = 0),
              (this.sharedNodes = new Map()),
              (this.latestValues = t),
              (this.root = i ? i.root || i : this),
              (this.path = i ? [...i.path, i] : []),
              (this.parent = i),
              (this.depth = i ? i.depth + 1 : 0);
            for (let t = 0; t < this.path.length; t++)
              this.path[t].shouldResetTransform = !0;
            this.root === this && (this.nodes = new n_());
          }
          addEventListener(t, e) {
            return (
              this.eventHandlers.has(t) ||
                this.eventHandlers.set(t, new nh.L()),
              this.eventHandlers.get(t).add(e)
            );
          }
          notifyListeners(t, ...e) {
            let i = this.eventHandlers.get(t);
            i && i.notify(...e);
          }
          hasListeners(t) {
            return this.eventHandlers.has(t);
          }
          mount(e, i = this.root.hasTreeAnimated) {
            if (this.instance) return;
            (this.isSVG = e instanceof SVGElement && "svg" !== e.tagName),
              (this.instance = e);
            let { layoutId: n, layout: r, visualElement: o } = this.options;
            if (
              (o && !o.current && o.mount(e),
              this.root.nodes.add(this),
              this.parent && this.parent.children.add(this),
              i && (r || n) && (this.isLayoutDirty = !0),
              t)
            ) {
              let i;
              let n = () => (this.root.updateBlockedByResize = !1);
              t(e, () => {
                (this.root.updateBlockedByResize = !0),
                  i && i(),
                  (i = (function (t, e) {
                    let i = t5.X.now(),
                      n = ({ timestamp: e }) => {
                        let r = e - i;
                        r >= 250 && ((0, tm.Pn)(n), t(r - 250));
                      };
                    return tm.Wi.read(n, !0), () => (0, tm.Pn)(n);
                  })(n, 0)),
                  no.hasAnimatedSinceResize &&
                    ((no.hasAnimatedSinceResize = !1), this.nodes.forEach(nZ));
              });
            }
            n && this.root.registerSharedNode(n, this),
              !1 !== this.options.animate &&
                o &&
                (n || r) &&
                this.addEventListener(
                  "didUpdate",
                  ({
                    delta: t,
                    hasLayoutChanged: e,
                    hasRelativeTargetChanged: i,
                    layout: n,
                  }) => {
                    if (this.isTreeAnimationBlocked()) {
                      (this.target = void 0), (this.relativeTarget = void 0);
                      return;
                    }
                    let r =
                        this.options.transition ||
                        o.getDefaultTransition() ||
                        n3,
                      {
                        onLayoutAnimationStart: s,
                        onLayoutAnimationComplete: a,
                      } = o.getProps(),
                      l = !this.targetLayout || !nk(this.targetLayout, n) || i,
                      u = !e && i;
                    if (
                      this.options.layoutRoot ||
                      (this.resumeFrom && this.resumeFrom.instance) ||
                      u ||
                      (e && (l || !this.currentAnimation))
                    ) {
                      this.resumeFrom &&
                        ((this.resumingFrom = this.resumeFrom),
                        (this.resumingFrom.resumingFrom = void 0)),
                        this.setAnimationOrigin(t, u);
                      let e = { ...tJ(r, "layout"), onPlay: s, onComplete: a };
                      (o.shouldReduceMotion || this.options.layoutRoot) &&
                        ((e.delay = 0), (e.type = !1)),
                        this.startAnimation(e);
                    } else
                      e || nZ(this),
                        this.isLead() &&
                          this.options.onExitComplete &&
                          this.options.onExitComplete();
                    this.targetLayout = n;
                  }
                );
          }
          unmount() {
            this.options.layoutId && this.willUpdate(),
              this.root.nodes.remove(this);
            let t = this.getStack();
            t && t.remove(this),
              this.parent && this.parent.children.delete(this),
              (this.instance = void 0),
              (0, tm.Pn)(this.updateProjection);
          }
          blockUpdate() {
            this.updateManuallyBlocked = !0;
          }
          unblockUpdate() {
            this.updateManuallyBlocked = !1;
          }
          isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize;
          }
          isTreeAnimationBlocked() {
            return (
              this.isAnimationBlocked ||
              (this.parent && this.parent.isTreeAnimationBlocked()) ||
              !1
            );
          }
          startUpdate() {
            !this.isUpdateBlocked() &&
              ((this.isUpdating = !0),
              this.nodes && this.nodes.forEach(nQ),
              this.animationId++);
          }
          getTransformTemplate() {
            let { visualElement: t } = this.options;
            return t && t.getProps().transformTemplate;
          }
          willUpdate(t = !0) {
            if (
              ((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())
            ) {
              this.options.onExitComplete && this.options.onExitComplete();
              return;
            }
            if (
              (window.HandoffCancelAllAnimations &&
                (function t(e) {
                  if (((e.hasCheckedOptimisedAppear = !0), e.root === e))
                    return !1;
                  let { visualElement: i } = e.options;
                  return (
                    !!i &&
                    (!!id(i) ||
                      (!!e.parent &&
                        !e.parent.hasCheckedOptimisedAppear &&
                        t(e.parent)))
                  );
                })(this) &&
                window.HandoffCancelAllAnimations(),
              this.root.isUpdating || this.root.startUpdate(),
              this.isLayoutDirty)
            )
              return;
            this.isLayoutDirty = !0;
            for (let t = 0; t < this.path.length; t++) {
              let e = this.path[t];
              (e.shouldResetTransform = !0),
                e.updateScroll("snapshot"),
                e.options.layoutRoot && e.willUpdate(!1);
            }
            let { layoutId: e, layout: i } = this.options;
            if (void 0 === e && !i) return;
            let n = this.getTransformTemplate();
            (this.prevTransformTemplateValue = n
              ? n(this.latestValues, "")
              : void 0),
              this.updateSnapshot(),
              t && this.notifyListeners("willUpdate");
          }
          update() {
            if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
              this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(nK);
              return;
            }
            this.isUpdating || this.nodes.forEach(nY),
              (this.isUpdating = !1),
              this.nodes.forEach(nq),
              this.nodes.forEach(nN),
              this.nodes.forEach(nz),
              this.clearAllSnapshots();
            let t = t5.X.now();
            (tm.frameData.delta = (0, eO.u)(
              0,
              1e3 / 60,
              t - tm.frameData.timestamp
            )),
              (tm.frameData.timestamp = t),
              (tm.frameData.isProcessing = !0),
              tm.S6.update.process(tm.frameData),
              tm.S6.preRender.process(tm.frameData),
              tm.S6.render.process(tm.frameData),
              (tm.frameData.isProcessing = !1);
          }
          didUpdate() {
            this.updateScheduled ||
              ((this.updateScheduled = !0), p.read(() => this.update()));
          }
          clearAllSnapshots() {
            this.nodes.forEach(nX), this.sharedNodes.forEach(n0);
          }
          scheduleUpdateProjection() {
            this.projectionUpdateScheduled ||
              ((this.projectionUpdateScheduled = !0),
              tm.Wi.preRender(this.updateProjection, !1, !0));
          }
          scheduleCheckAfterUnmount() {
            tm.Wi.postRender(() => {
              this.isLayoutDirty
                ? this.root.didUpdate()
                : this.root.checkUpdateFailed();
            });
          }
          updateSnapshot() {
            !this.snapshot && this.instance && (this.snapshot = this.measure());
          }
          updateLayout() {
            if (
              !this.instance ||
              (this.updateScroll(),
              !(this.options.alwaysMeasureLayout && this.isLead()) &&
                !this.isLayoutDirty)
            )
              return;
            if (this.resumeFrom && !this.resumeFrom.instance)
              for (let t = 0; t < this.path.length; t++)
                this.path[t].updateScroll();
            let t = this.layout;
            (this.layout = this.measure(!1)),
              (this.layoutCorrected = iH()),
              (this.isLayoutDirty = !1),
              (this.projectionDelta = void 0),
              this.notifyListeners("measure", this.layout.layoutBox);
            let { visualElement: e } = this.options;
            e &&
              e.notify(
                "LayoutMeasure",
                this.layout.layoutBox,
                t ? t.layoutBox : void 0
              );
          }
          updateScroll(t = "measure") {
            let e = !!(this.options.layoutScroll && this.instance);
            this.scroll &&
              this.scroll.animationId === this.root.animationId &&
              this.scroll.phase === t &&
              (e = !1),
              e &&
                (this.scroll = {
                  animationId: this.root.animationId,
                  phase: t,
                  isRoot: n(this.instance),
                  offset: i(this.instance),
                });
          }
          resetTransform() {
            if (!r) return;
            let t = this.isLayoutDirty || this.shouldResetTransform,
              e = this.projectionDelta && !nR(this.projectionDelta),
              i = this.getTransformTemplate(),
              n = i ? i(this.latestValues, "") : void 0,
              o = n !== this.prevTransformTemplateValue;
            t &&
              (e || iZ(this.latestValues) || o) &&
              (r(this.instance, n),
              (this.shouldResetTransform = !1),
              this.scheduleRender());
          }
          measure(t = !0) {
            var e;
            let i = this.measurePageBox(),
              n = this.removeElementScroll(i);
            return (
              t && (n = this.removeTransform(n)),
              n9((e = n).x),
              n9(e.y),
              {
                animationId: this.root.animationId,
                measuredBox: i,
                layoutBox: n,
                latestValues: {},
                source: this.id,
              }
            );
          }
          measurePageBox() {
            let { visualElement: t } = this.options;
            if (!t) return iH();
            let e = t.measureViewportBox(),
              { scroll: i } = this.root;
            return i && (i2(e.x, i.offset.x), i2(e.y, i.offset.y)), e;
          }
          removeElementScroll(t) {
            let e = iH();
            nb(e, t);
            for (let i = 0; i < this.path.length; i++) {
              let n = this.path[i],
                { scroll: r, options: o } = n;
              if (n !== this.root && r && o.layoutScroll) {
                if (r.isRoot) {
                  nb(e, t);
                  let { scroll: i } = this.root;
                  i && (i2(e.x, -i.offset.x), i2(e.y, -i.offset.y));
                }
                i2(e.x, r.offset.x), i2(e.y, r.offset.y);
              }
            }
            return e;
          }
          applyTransform(t, e = !1) {
            let i = iH();
            nb(i, t);
            for (let t = 0; t < this.path.length; t++) {
              let n = this.path[t];
              !e &&
                n.options.layoutScroll &&
                n.scroll &&
                n !== n.root &&
                i4(i, { x: -n.scroll.offset.x, y: -n.scroll.offset.y }),
                iZ(n.latestValues) && i4(i, n.latestValues);
            }
            return iZ(this.latestValues) && i4(i, this.latestValues), i;
          }
          removeTransform(t) {
            let e = iH();
            nb(e, t);
            for (let t = 0; t < this.path.length; t++) {
              let i = this.path[t];
              if (!i.instance || !iZ(i.latestValues)) continue;
              iq(i.latestValues) && i.updateSnapshot();
              let n = iH();
              nb(n, i.measurePageBox()),
                nE(
                  e,
                  i.latestValues,
                  i.snapshot ? i.snapshot.layoutBox : void 0,
                  n
                );
            }
            return iZ(this.latestValues) && nE(e, this.latestValues), e;
          }
          setTargetDelta(t) {
            (this.targetDelta = t),
              this.root.scheduleUpdateProjection(),
              (this.isProjectionDirty = !0);
          }
          setOptions(t) {
            this.options = {
              ...this.options,
              ...t,
              crossfade: void 0 === t.crossfade || t.crossfade,
            };
          }
          clearMeasurements() {
            (this.scroll = void 0),
              (this.layout = void 0),
              (this.snapshot = void 0),
              (this.prevTransformTemplateValue = void 0),
              (this.targetDelta = void 0),
              (this.target = void 0),
              (this.isLayoutDirty = !1);
          }
          forceRelativeParentToResolveTarget() {
            this.relativeParent &&
              this.relativeParent.resolvedRelativeTargetAt !==
                tm.frameData.timestamp &&
              this.relativeParent.resolveTargetDelta(!0);
          }
          resolveTargetDelta(t = !1) {
            var e, i, n, r;
            let o = this.getLead();
            this.isProjectionDirty ||
              (this.isProjectionDirty = o.isProjectionDirty),
              this.isTransformDirty ||
                (this.isTransformDirty = o.isTransformDirty),
              this.isSharedProjectionDirty ||
                (this.isSharedProjectionDirty = o.isSharedProjectionDirty);
            let s = !!this.resumingFrom || this !== o;
            if (
              !(
                t ||
                (s && this.isSharedProjectionDirty) ||
                this.isProjectionDirty ||
                (null === (e = this.parent) || void 0 === e
                  ? void 0
                  : e.isProjectionDirty) ||
                this.attemptToResolveRelativeTarget
              )
            )
              return;
            let { layout: a, layoutId: l } = this.options;
            if (this.layout && (a || l)) {
              if (
                ((this.resolvedRelativeTargetAt = tm.frameData.timestamp),
                !this.targetDelta && !this.relativeTarget)
              ) {
                let t = this.getClosestProjectingParent();
                t && t.layout && 1 !== this.animationProgress
                  ? ((this.relativeParent = t),
                    this.forceRelativeParentToResolveTarget(),
                    (this.relativeTarget = iH()),
                    (this.relativeTargetOrigin = iH()),
                    iF(
                      this.relativeTargetOrigin,
                      this.layout.layoutBox,
                      t.layout.layoutBox
                    ),
                    nb(this.relativeTarget, this.relativeTargetOrigin))
                  : (this.relativeParent = this.relativeTarget = void 0);
              }
              if (this.relativeTarget || this.targetDelta) {
                if (
                  ((this.target ||
                    ((this.target = iH()), (this.targetWithTransforms = iH())),
                  this.relativeTarget &&
                    this.relativeTargetOrigin &&
                    this.relativeParent &&
                    this.relativeParent.target)
                    ? (this.forceRelativeParentToResolveTarget(),
                      (i = this.target),
                      (n = this.relativeTarget),
                      (r = this.relativeParent.target),
                      i_(i.x, n.x, r.x),
                      i_(i.y, n.y, r.y))
                    : this.targetDelta
                    ? (this.resumingFrom
                        ? (this.target = this.applyTransform(
                            this.layout.layoutBox
                          ))
                        : nb(this.target, this.layout.layoutBox),
                      i0(this.target, this.targetDelta))
                    : nb(this.target, this.layout.layoutBox),
                  this.attemptToResolveRelativeTarget)
                ) {
                  this.attemptToResolveRelativeTarget = !1;
                  let t = this.getClosestProjectingParent();
                  t &&
                  !!t.resumingFrom == !!this.resumingFrom &&
                  !t.options.layoutScroll &&
                  t.target &&
                  1 !== this.animationProgress
                    ? ((this.relativeParent = t),
                      this.forceRelativeParentToResolveTarget(),
                      (this.relativeTarget = iH()),
                      (this.relativeTargetOrigin = iH()),
                      iF(this.relativeTargetOrigin, this.target, t.target),
                      nb(this.relativeTarget, this.relativeTargetOrigin))
                    : (this.relativeParent = this.relativeTarget = void 0);
                }
                nI.resolvedTargetDeltas++;
              }
            }
          }
          getClosestProjectingParent() {
            return !this.parent ||
              iq(this.parent.latestValues) ||
              iG(this.parent.latestValues)
              ? void 0
              : this.parent.isProjecting()
              ? this.parent
              : this.parent.getClosestProjectingParent();
          }
          isProjecting() {
            return !!(
              (this.relativeTarget ||
                this.targetDelta ||
                this.options.layoutRoot) &&
              this.layout
            );
          }
          calcProjection() {
            var t;
            let e = this.getLead(),
              i = !!this.resumingFrom || this !== e,
              n = !0;
            if (
              ((this.isProjectionDirty ||
                (null === (t = this.parent) || void 0 === t
                  ? void 0
                  : t.isProjectionDirty)) &&
                (n = !1),
              i &&
                (this.isSharedProjectionDirty || this.isTransformDirty) &&
                (n = !1),
              this.resolvedRelativeTargetAt === tm.frameData.timestamp &&
                (n = !1),
              n)
            )
              return;
            let { layout: r, layoutId: o } = this.options;
            if (
              ((this.isTreeAnimating = !!(
                (this.parent && this.parent.isTreeAnimating) ||
                this.currentAnimation ||
                this.pendingAnimation
              )),
              this.isTreeAnimating ||
                (this.targetDelta = this.relativeTarget = void 0),
              !this.layout || !(r || o))
            )
              return;
            nb(this.layoutCorrected, this.layout.layoutBox);
            let s = this.treeScale.x,
              a = this.treeScale.y;
            !(function (t, e, i, n = !1) {
              let r, o;
              let s = i.length;
              if (s) {
                e.x = e.y = 1;
                for (let a = 0; a < s; a++) {
                  o = (r = i[a]).projectionDelta;
                  let s = r.instance;
                  (!s || !s.style || "contents" !== s.style.display) &&
                    (n &&
                      r.options.layoutScroll &&
                      r.scroll &&
                      r !== r.root &&
                      i4(t, { x: -r.scroll.offset.x, y: -r.scroll.offset.y }),
                    o && ((e.x *= o.x.scale), (e.y *= o.y.scale), i0(t, o)),
                    n && iZ(r.latestValues) && i4(t, r.latestValues));
                }
                (e.x = i1(e.x)), (e.y = i1(e.y));
              }
            })(this.layoutCorrected, this.treeScale, this.path, i),
              e.layout &&
                !e.target &&
                (1 !== this.treeScale.x || 1 !== this.treeScale.y) &&
                ((e.target = e.layout.layoutBox),
                (e.targetWithTransforms = iH()));
            let { target: l } = e;
            if (!l) {
              this.projectionTransform &&
                ((this.projectionDelta = iz()),
                (this.projectionTransform = "none"),
                this.scheduleRender());
              return;
            }
            this.projectionDelta ||
              ((this.projectionDelta = iz()),
              (this.projectionDeltaWithTransform = iz()));
            let u = this.projectionTransform;
            ij(
              this.projectionDelta,
              this.layoutCorrected,
              l,
              this.latestValues
            ),
              (this.projectionTransform = nM(
                this.projectionDelta,
                this.treeScale
              )),
              (this.projectionTransform !== u ||
                this.treeScale.x !== s ||
                this.treeScale.y !== a) &&
                ((this.hasProjected = !0),
                this.scheduleRender(),
                this.notifyListeners("projectionUpdate", l)),
              nI.recalculatedProjection++;
          }
          hide() {
            this.isVisible = !1;
          }
          show() {
            this.isVisible = !0;
          }
          scheduleRender(t = !0) {
            if (
              (this.options.scheduleRender && this.options.scheduleRender(), t)
            ) {
              let t = this.getStack();
              t && t.scheduleRender();
            }
            this.resumingFrom &&
              !this.resumingFrom.instance &&
              (this.resumingFrom = void 0);
          }
          setAnimationOrigin(t, e = !1) {
            let i;
            let n = this.snapshot,
              r = n ? n.latestValues : {},
              o = { ...this.latestValues },
              s = iz();
            (this.relativeParent && this.relativeParent.options.layoutRoot) ||
              (this.relativeTarget = this.relativeTargetOrigin = void 0),
              (this.attemptToResolveRelativeTarget = !e);
            let a = iH(),
              l =
                (n ? n.source : void 0) !==
                (this.layout ? this.layout.source : void 0),
              u = this.getStack(),
              c = !u || u.members.length <= 1,
              h = !!(
                l &&
                !c &&
                !0 === this.options.crossfade &&
                !this.path.some(n5)
              );
            (this.animationProgress = 0),
              (this.mixTargetDelta = (e) => {
                let n = e / 1e3;
                if (
                  (n1(s.x, t.x, n),
                  n1(s.y, t.y, n),
                  this.setTargetDelta(s),
                  this.relativeTarget &&
                    this.relativeTargetOrigin &&
                    this.layout &&
                    this.relativeParent &&
                    this.relativeParent.layout)
                ) {
                  var u, d, p, f;
                  iF(
                    a,
                    this.layout.layoutBox,
                    this.relativeParent.layout.layoutBox
                  ),
                    (p = this.relativeTarget),
                    (f = this.relativeTargetOrigin),
                    n2(p.x, f.x, a.x, n),
                    n2(p.y, f.y, a.y, n),
                    i &&
                      ((u = this.relativeTarget),
                      (d = i),
                      u.x.min === d.x.min &&
                        u.x.max === d.x.max &&
                        u.y.min === d.y.min &&
                        u.y.max === d.y.max) &&
                      (this.isProjectionDirty = !1),
                    i || (i = iH()),
                    nb(i, this.relativeTarget);
                }
                l &&
                  ((this.animationValues = o),
                  (function (t, e, i, n, r, o) {
                    r
                      ? ((t.opacity = (0, iV.t)(
                          0,
                          void 0 !== i.opacity ? i.opacity : 1,
                          ny(n)
                        )),
                        (t.opacityExit = (0, iV.t)(
                          void 0 !== e.opacity ? e.opacity : 1,
                          0,
                          ng(n)
                        )))
                      : o &&
                        (t.opacity = (0, iV.t)(
                          void 0 !== e.opacity ? e.opacity : 1,
                          void 0 !== i.opacity ? i.opacity : 1,
                          n
                        ));
                    for (let r = 0; r < np; r++) {
                      let o = `border${nd[r]}Radius`,
                        s = nv(e, o),
                        a = nv(i, o);
                      (void 0 !== s || void 0 !== a) &&
                        (s || (s = 0),
                        a || (a = 0),
                        0 === s || 0 === a || nm(s) === nm(a)
                          ? ((t[o] = Math.max((0, iV.t)(nf(s), nf(a), n), 0)),
                            (W.aQ.test(a) || W.aQ.test(s)) && (t[o] += "%"))
                          : (t[o] = a));
                    }
                    (e.rotate || i.rotate) &&
                      (t.rotate = (0, iV.t)(e.rotate || 0, i.rotate || 0, n));
                  })(o, r, this.latestValues, n, h, c)),
                  this.root.scheduleUpdateProjection(),
                  this.scheduleRender(),
                  (this.animationProgress = n);
              }),
              this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
          }
          startAnimation(t) {
            this.notifyListeners("animationStart"),
              this.currentAnimation && this.currentAnimation.stop(),
              this.resumingFrom &&
                this.resumingFrom.currentAnimation &&
                this.resumingFrom.currentAnimation.stop(),
              this.pendingAnimation &&
                ((0, tm.Pn)(this.pendingAnimation),
                (this.pendingAnimation = void 0)),
              (this.pendingAnimation = tm.Wi.update(() => {
                (no.hasAnimatedSinceResize = !0),
                  (this.currentAnimation = (function (t, e, i) {
                    let n = _(0) ? 0 : (0, ih.BX)(0);
                    return n.start(iu("", n, 1e3, i)), n.animation;
                  })(0, 0, {
                    ...t,
                    onUpdate: (e) => {
                      this.mixTargetDelta(e), t.onUpdate && t.onUpdate(e);
                    },
                    onComplete: () => {
                      t.onComplete && t.onComplete(), this.completeAnimation();
                    },
                  })),
                  this.resumingFrom &&
                    (this.resumingFrom.currentAnimation =
                      this.currentAnimation),
                  (this.pendingAnimation = void 0);
              }));
          }
          completeAnimation() {
            this.resumingFrom &&
              ((this.resumingFrom.currentAnimation = void 0),
              (this.resumingFrom.preserveOpacity = void 0));
            let t = this.getStack();
            t && t.exitAnimationComplete(),
              (this.resumingFrom =
                this.currentAnimation =
                this.animationValues =
                  void 0),
              this.notifyListeners("animationComplete");
          }
          finishAnimation() {
            this.currentAnimation &&
              (this.mixTargetDelta && this.mixTargetDelta(1e3),
              this.currentAnimation.stop()),
              this.completeAnimation();
          }
          applyTransformsToTarget() {
            let t = this.getLead(),
              {
                targetWithTransforms: e,
                target: i,
                layout: n,
                latestValues: r,
              } = t;
            if (e && i && n) {
              if (
                this !== t &&
                this.layout &&
                n &&
                n8(
                  this.options.animationType,
                  this.layout.layoutBox,
                  n.layoutBox
                )
              ) {
                i = this.target || iH();
                let e = iO(this.layout.layoutBox.x);
                (i.x.min = t.target.x.min), (i.x.max = i.x.min + e);
                let n = iO(this.layout.layoutBox.y);
                (i.y.min = t.target.y.min), (i.y.max = i.y.min + n);
              }
              nb(e, i),
                i4(e, r),
                ij(
                  this.projectionDeltaWithTransform,
                  this.layoutCorrected,
                  e,
                  r
                );
            }
          }
          registerSharedNode(t, e) {
            this.sharedNodes.has(t) || this.sharedNodes.set(t, new nD()),
              this.sharedNodes.get(t).add(e);
            let i = e.options.initialPromotionConfig;
            e.promote({
              transition: i ? i.transition : void 0,
              preserveFollowOpacity:
                i && i.shouldPreserveFollowOpacity
                  ? i.shouldPreserveFollowOpacity(e)
                  : void 0,
            });
          }
          isLead() {
            let t = this.getStack();
            return !t || t.lead === this;
          }
          getLead() {
            var t;
            let { layoutId: e } = this.options;
            return (
              (e &&
                (null === (t = this.getStack()) || void 0 === t
                  ? void 0
                  : t.lead)) ||
              this
            );
          }
          getPrevLead() {
            var t;
            let { layoutId: e } = this.options;
            return e
              ? null === (t = this.getStack()) || void 0 === t
                ? void 0
                : t.prevLead
              : void 0;
          }
          getStack() {
            let { layoutId: t } = this.options;
            if (t) return this.root.sharedNodes.get(t);
          }
          promote({
            needsReset: t,
            transition: e,
            preserveFollowOpacity: i,
          } = {}) {
            let n = this.getStack();
            n && n.promote(this, i),
              t && ((this.projectionDelta = void 0), (this.needsReset = !0)),
              e && this.setOptions({ transition: e });
          }
          relegate() {
            let t = this.getStack();
            return !!t && t.relegate(this);
          }
          resetSkewAndRotation() {
            let { visualElement: t } = this.options;
            if (!t) return;
            let e = !1,
              { latestValues: i } = t;
            if (
              ((i.z ||
                i.rotate ||
                i.rotateX ||
                i.rotateY ||
                i.rotateZ ||
                i.skewX ||
                i.skewY) &&
                (e = !0),
              !e)
            )
              return;
            let n = {};
            i.z && n$("z", t, n, this.animationValues);
            for (let e = 0; e < nL.length; e++)
              n$(`rotate${nL[e]}`, t, n, this.animationValues),
                n$(`skew${nL[e]}`, t, n, this.animationValues);
            for (let e in (t.render(), n))
              t.setStaticValue(e, n[e]),
                this.animationValues && (this.animationValues[e] = n[e]);
            t.scheduleRender();
          }
          getProjectionStyles(t) {
            var e, i;
            if (!this.instance || this.isSVG) return;
            if (!this.isVisible) return nF;
            let n = { visibility: "" },
              r = this.getTransformTemplate();
            if (this.needsReset)
              return (
                (this.needsReset = !1),
                (n.opacity = ""),
                (n.pointerEvents =
                  tp(null == t ? void 0 : t.pointerEvents) || ""),
                (n.transform = r ? r(this.latestValues, "") : "none"),
                n
              );
            let o = this.getLead();
            if (!this.projectionDelta || !this.layout || !o.target) {
              let e = {};
              return (
                this.options.layoutId &&
                  ((e.opacity =
                    void 0 !== this.latestValues.opacity
                      ? this.latestValues.opacity
                      : 1),
                  (e.pointerEvents =
                    tp(null == t ? void 0 : t.pointerEvents) || "")),
                this.hasProjected &&
                  !iZ(this.latestValues) &&
                  ((e.transform = r ? r({}, "") : "none"),
                  (this.hasProjected = !1)),
                e
              );
            }
            let s = o.animationValues || o.latestValues;
            this.applyTransformsToTarget(),
              (n.transform = nM(
                this.projectionDeltaWithTransform,
                this.treeScale,
                s
              )),
              r && (n.transform = r(s, n.transform));
            let { x: a, y: l } = this.projectionDelta;
            for (let t in ((n.transformOrigin = `${100 * a.origin}% ${
              100 * l.origin
            }% 0`),
            o.animationValues
              ? (n.opacity =
                  o === this
                    ? null !==
                        (i =
                          null !== (e = s.opacity) && void 0 !== e
                            ? e
                            : this.latestValues.opacity) && void 0 !== i
                      ? i
                      : 1
                    : this.preserveOpacity
                    ? this.latestValues.opacity
                    : s.opacityExit)
              : (n.opacity =
                  o === this
                    ? void 0 !== s.opacity
                      ? s.opacity
                      : ""
                    : void 0 !== s.opacityExit
                    ? s.opacityExit
                    : 0),
            O)) {
              if (void 0 === s[t]) continue;
              let { correct: e, applyTo: i } = O[t],
                r = "none" === n.transform ? s[t] : e(s[t], o);
              if (i) {
                let t = i.length;
                for (let e = 0; e < t; e++) n[i[e]] = r;
              } else n[t] = r;
            }
            return (
              this.options.layoutId &&
                (n.pointerEvents =
                  o === this
                    ? tp(null == t ? void 0 : t.pointerEvents) || ""
                    : "none"),
              n
            );
          }
          clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0;
          }
          resetTree() {
            this.root.nodes.forEach((t) => {
              var e;
              return null === (e = t.currentAnimation) || void 0 === e
                ? void 0
                : e.stop();
            }),
              this.root.nodes.forEach(nK),
              this.root.sharedNodes.clear();
          }
        };
      }
      function nN(t) {
        t.updateLayout();
      }
      function nz(t) {
        var e;
        let i =
          (null === (e = t.resumeFrom) || void 0 === e ? void 0 : e.snapshot) ||
          t.snapshot;
        if (t.isLead() && t.layout && i && t.hasListeners("didUpdate")) {
          let { layoutBox: e, measuredBox: n } = t.layout,
            { animationType: r } = t.options,
            o = i.source !== t.layout.source;
          "size" === r
            ? iX((t) => {
                let n = o ? i.measuredBox[t] : i.layoutBox[t],
                  r = iO(n);
                (n.min = e[t].min), (n.max = n.min + r);
              })
            : n8(r, i.layoutBox, e) &&
              iX((n) => {
                let r = o ? i.measuredBox[n] : i.layoutBox[n],
                  s = iO(e[n]);
                (r.max = r.min + s),
                  t.relativeTarget &&
                    !t.currentAnimation &&
                    ((t.isProjectionDirty = !0),
                    (t.relativeTarget[n].max = t.relativeTarget[n].min + s));
              });
          let s = iz();
          ij(s, e, i.layoutBox);
          let a = iz();
          o
            ? ij(a, t.applyTransform(n, !0), i.measuredBox)
            : ij(a, e, i.layoutBox);
          let l = !nR(s),
            u = !1;
          if (!t.resumeFrom) {
            let n = t.getClosestProjectingParent();
            if (n && !n.resumeFrom) {
              let { snapshot: r, layout: o } = n;
              if (r && o) {
                let s = iH();
                iF(s, i.layoutBox, r.layoutBox);
                let a = iH();
                iF(a, e, o.layoutBox),
                  nk(s, a) || (u = !0),
                  n.options.layoutRoot &&
                    ((t.relativeTarget = a),
                    (t.relativeTargetOrigin = s),
                    (t.relativeParent = n));
              }
            }
          }
          t.notifyListeners("didUpdate", {
            layout: e,
            snapshot: i,
            delta: a,
            layoutDelta: s,
            hasLayoutChanged: l,
            hasRelativeTargetChanged: u,
          });
        } else if (t.isLead()) {
          let { onExitComplete: e } = t.options;
          e && e();
        }
        t.options.transition = void 0;
      }
      function nU(t) {
        nI.totalNodes++,
          t.parent &&
            (t.isProjecting() ||
              (t.isProjectionDirty = t.parent.isProjectionDirty),
            t.isSharedProjectionDirty ||
              (t.isSharedProjectionDirty = !!(
                t.isProjectionDirty ||
                t.parent.isProjectionDirty ||
                t.parent.isSharedProjectionDirty
              )),
            t.isTransformDirty ||
              (t.isTransformDirty = t.parent.isTransformDirty));
      }
      function nH(t) {
        t.isProjectionDirty =
          t.isSharedProjectionDirty =
          t.isTransformDirty =
            !1;
      }
      function nX(t) {
        t.clearSnapshot();
      }
      function nK(t) {
        t.clearMeasurements();
      }
      function nY(t) {
        t.isLayoutDirty = !1;
      }
      function nq(t) {
        let { visualElement: e } = t.options;
        e &&
          e.getProps().onBeforeLayoutMeasure &&
          e.notify("BeforeLayoutMeasure"),
          t.resetTransform();
      }
      function nZ(t) {
        t.finishAnimation(),
          (t.targetDelta = t.relativeTarget = t.target = void 0),
          (t.isProjectionDirty = !0);
      }
      function nG(t) {
        t.resolveTargetDelta();
      }
      function nJ(t) {
        t.calcProjection();
      }
      function nQ(t) {
        t.resetSkewAndRotation();
      }
      function n0(t) {
        t.removeLeadSnapshot();
      }
      function n1(t, e, i) {
        (t.translate = (0, iV.t)(e.translate, 0, i)),
          (t.scale = (0, iV.t)(e.scale, 1, i)),
          (t.origin = e.origin),
          (t.originPoint = e.originPoint);
      }
      function n2(t, e, i, n) {
        (t.min = (0, iV.t)(e.min, i.min, n)),
          (t.max = (0, iV.t)(e.max, i.max, n));
      }
      function n5(t) {
        return t.animationValues && void 0 !== t.animationValues.opacityExit;
      }
      let n3 = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
        n6 = (t) =>
          "undefined" != typeof navigator &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().includes(t),
        n4 = n6("applewebkit/") && !n6("chrome/") ? Math.round : tj.Z;
      function n9(t) {
        (t.min = n4(t.min)), (t.max = n4(t.max));
      }
      function n8(t, e, i) {
        return (
          "position" === t ||
          ("preserve-aspect" === t && !iD(nV(e), nV(i), 0.2))
        );
      }
      let n7 = nW({
          attachResizeListener: (t, e) => tg(t, "resize", e),
          measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop,
          }),
          checkIsScrollRoot: () => !0,
        }),
        rt = { current: void 0 },
        re = nW({
          measureScroll: (t) => ({ x: t.scrollLeft, y: t.scrollTop }),
          defaultParent: () => {
            if (!rt.current) {
              let t = new n7({});
              t.mount(window),
                t.setOptions({ layoutScroll: !0 }),
                (rt.current = t);
            }
            return rt.current;
          },
          resetTransform: (t, e) => {
            t.style.transform = void 0 !== e ? e : "none";
          },
          checkIsScrollRoot: (t) =>
            "fixed" === window.getComputedStyle(t).position,
        }),
        ri = { current: null },
        rn = { current: !1 },
        rr = new WeakMap(),
        ro = [...es, ew.$, ef.P],
        rs = (t) => ro.find(eo(t)),
        ra = Object.keys(T),
        rl = ra.length,
        ru = [
          "AnimationStart",
          "AnimationComplete",
          "Update",
          "BeforeLayoutMeasure",
          "LayoutMeasure",
          "LayoutAnimationStart",
          "LayoutAnimationComplete",
        ],
        rc = x.length;
      class rh {
        scrapeMotionValuesFromProps(t, e, i) {
          return {};
        }
        constructor(
          {
            parent: t,
            props: e,
            presenceContext: i,
            reducedMotionConfig: n,
            blockInitialAnimation: r,
            visualState: o,
          },
          s = {}
        ) {
          (this.resolveKeyframes = (t, e, i, n) =>
            new this.KeyframeResolver(t, e, i, n, this)),
            (this.current = null),
            (this.children = new Set()),
            (this.isVariantNode = !1),
            (this.isControllingVariants = !1),
            (this.shouldReduceMotion = null),
            (this.values = new Map()),
            (this.KeyframeResolver = ep),
            (this.features = {}),
            (this.valueSubscriptions = new Map()),
            (this.prevMotionValues = {}),
            (this.events = {}),
            (this.propEventSubscriptions = {}),
            (this.notifyUpdate = () =>
              this.notify("Update", this.latestValues)),
            (this.render = () => {
              this.current &&
                (this.triggerBuild(),
                this.renderInstance(
                  this.current,
                  this.renderState,
                  this.props.style,
                  this.projection
                ));
            }),
            (this.scheduleRender = () => tm.Wi.render(this.render, !1, !0));
          let { latestValues: a, renderState: l } = o;
          (this.latestValues = a),
            (this.baseTarget = { ...a }),
            (this.initialValues = e.initial ? { ...a } : {}),
            (this.renderState = l),
            (this.parent = t),
            (this.props = e),
            (this.presenceContext = i),
            (this.depth = t ? t.depth + 1 : 0),
            (this.reducedMotionConfig = n),
            (this.options = s),
            (this.blockInitialAnimation = !!r),
            (this.isControllingVariants = w(e)),
            (this.isVariantNode = b(e)),
            this.isVariantNode && (this.variantChildren = new Set()),
            (this.manuallyAnimateOnMount = !!(t && t.current));
          let { willChange: u, ...c } = this.scrapeMotionValuesFromProps(
            e,
            {},
            this
          );
          for (let t in c) {
            let e = c[t];
            void 0 !== a[t] && _(e) && (e.set(a[t], !1), ic(u) && u.add(t));
          }
        }
        mount(t) {
          (this.current = t),
            rr.set(t, this),
            this.projection &&
              !this.projection.instance &&
              this.projection.mount(t),
            this.parent &&
              this.isVariantNode &&
              !this.isControllingVariants &&
              (this.removeFromVariantTree = this.parent.addVariantChild(this)),
            this.values.forEach((t, e) => this.bindToMotionValue(e, t)),
            rn.current ||
              (function () {
                if (((rn.current = !0), A.j)) {
                  if (window.matchMedia) {
                    let t = window.matchMedia("(prefers-reduced-motion)"),
                      e = () => (ri.current = t.matches);
                    t.addListener(e), e();
                  } else ri.current = !1;
                }
              })(),
            (this.shouldReduceMotion =
              "never" !== this.reducedMotionConfig &&
              ("always" === this.reducedMotionConfig || ri.current)),
            this.parent && this.parent.children.add(this),
            this.update(this.props, this.presenceContext);
        }
        unmount() {
          var t;
          for (let t in (rr.delete(this.current),
          this.projection && this.projection.unmount(),
          (0, tm.Pn)(this.notifyUpdate),
          (0, tm.Pn)(this.render),
          this.valueSubscriptions.forEach((t) => t()),
          this.removeFromVariantTree && this.removeFromVariantTree(),
          this.parent && this.parent.children.delete(this),
          this.events))
            this.events[t].clear();
          for (let e in this.features)
            null === (t = this.features[e]) || void 0 === t || t.unmount();
          this.current = null;
        }
        bindToMotionValue(t, e) {
          let i = M.has(t),
            n = e.on("change", (e) => {
              (this.latestValues[t] = e),
                this.props.onUpdate && tm.Wi.preRender(this.notifyUpdate),
                i && this.projection && (this.projection.isTransformDirty = !0);
            }),
            r = e.on("renderRequest", this.scheduleRender);
          this.valueSubscriptions.set(t, () => {
            n(), r(), e.owner && e.stop();
          });
        }
        sortNodePosition(t) {
          return this.current &&
            this.sortInstanceNodePosition &&
            this.type === t.type
            ? this.sortInstanceNodePosition(this.current, t.current)
            : 0;
        }
        loadFeatures({ children: t, ...e }, i, n, r) {
          let o, s;
          for (let t = 0; t < rl; t++) {
            let i = ra[t],
              {
                isEnabled: n,
                Feature: r,
                ProjectionNode: a,
                MeasureLayout: l,
              } = T[i];
            a && (o = a),
              n(e) &&
                (!this.features[i] && r && (this.features[i] = new r(this)),
                l && (s = l));
          }
          if (
            ("html" === this.type || "svg" === this.type) &&
            !this.projection &&
            o
          ) {
            let {
              layoutId: t,
              layout: i,
              drag: n,
              dragConstraints: s,
              layoutScroll: a,
              layoutRoot: l,
            } = e;
            (this.projection = new o(
              this.latestValues,
              e["data-framer-portal-id"]
                ? void 0
                : (function t(e) {
                    if (e)
                      return !1 !== e.options.allowProjection
                        ? e.projection
                        : t(e.parent);
                  })(this.parent)
            )),
              this.projection.setOptions({
                layoutId: t,
                layout: i,
                alwaysMeasureLayout: !!n || (s && m(s)),
                visualElement: this,
                scheduleRender: () => this.scheduleRender(),
                animationType: "string" == typeof i ? i : "both",
                initialPromotionConfig: r,
                layoutScroll: a,
                layoutRoot: l,
              });
          }
          return s;
        }
        updateFeatures() {
          for (let t in this.features) {
            let e = this.features[t];
            e.isMounted ? e.update() : (e.mount(), (e.isMounted = !0));
          }
        }
        triggerBuild() {
          this.build(
            this.renderState,
            this.latestValues,
            this.options,
            this.props
          );
        }
        measureViewportBox() {
          return this.current
            ? this.measureInstanceViewportBox(this.current, this.props)
            : iH();
        }
        getStaticValue(t) {
          return this.latestValues[t];
        }
        setStaticValue(t, e) {
          this.latestValues[t] = e;
        }
        update(t, e) {
          (t.transformTemplate || this.props.transformTemplate) &&
            this.scheduleRender(),
            (this.prevProps = this.props),
            (this.props = t),
            (this.prevPresenceContext = this.presenceContext),
            (this.presenceContext = e);
          for (let e = 0; e < ru.length; e++) {
            let i = ru[e];
            this.propEventSubscriptions[i] &&
              (this.propEventSubscriptions[i](),
              delete this.propEventSubscriptions[i]);
            let n = t["on" + i];
            n && (this.propEventSubscriptions[i] = this.on(i, n));
          }
          (this.prevMotionValues = (function (t, e, i) {
            let { willChange: n } = e;
            for (let r in e) {
              let o = e[r],
                s = i[r];
              if (_(o)) t.addValue(r, o), ic(n) && n.add(r);
              else if (_(s))
                t.addValue(r, (0, ih.BX)(o, { owner: t })),
                  ic(n) && n.remove(r);
              else if (s !== o) {
                if (t.hasValue(r)) {
                  let e = t.getValue(r);
                  !0 === e.liveStyle ? e.jump(o) : e.hasAnimated || e.set(o);
                } else {
                  let e = t.getStaticValue(r);
                  t.addValue(r, (0, ih.BX)(void 0 !== e ? e : o, { owner: t }));
                }
              }
            }
            for (let n in i) void 0 === e[n] && t.removeValue(n);
            return e;
          })(
            this,
            this.scrapeMotionValuesFromProps(t, this.prevProps, this),
            this.prevMotionValues
          )),
            this.handleChildMotionValue && this.handleChildMotionValue();
        }
        getProps() {
          return this.props;
        }
        getVariant(t) {
          return this.props.variants ? this.props.variants[t] : void 0;
        }
        getDefaultTransition() {
          return this.props.transition;
        }
        getTransformPagePoint() {
          return this.props.transformPagePoint;
        }
        getClosestVariantNode() {
          return this.isVariantNode
            ? this
            : this.parent
            ? this.parent.getClosestVariantNode()
            : void 0;
        }
        getVariantContext(t = !1) {
          if (t) return this.parent ? this.parent.getVariantContext() : void 0;
          if (!this.isControllingVariants) {
            let t = (this.parent && this.parent.getVariantContext()) || {};
            return (
              void 0 !== this.props.initial && (t.initial = this.props.initial),
              t
            );
          }
          let e = {};
          for (let t = 0; t < rc; t++) {
            let i = x[t],
              n = this.props[i];
            (v(n) || !1 === n) && (e[i] = n);
          }
          return e;
        }
        addVariantChild(t) {
          let e = this.getClosestVariantNode();
          if (e)
            return (
              e.variantChildren && e.variantChildren.add(t),
              () => e.variantChildren.delete(t)
            );
        }
        addValue(t, e) {
          let i = this.values.get(t);
          e !== i &&
            (i && this.removeValue(t),
            this.bindToMotionValue(t, e),
            this.values.set(t, e),
            (this.latestValues[t] = e.get()));
        }
        removeValue(t) {
          this.values.delete(t);
          let e = this.valueSubscriptions.get(t);
          e && (e(), this.valueSubscriptions.delete(t)),
            delete this.latestValues[t],
            this.removeValueFromRenderState(t, this.renderState);
        }
        hasValue(t) {
          return this.values.has(t);
        }
        getValue(t, e) {
          if (this.props.values && this.props.values[t])
            return this.props.values[t];
          let i = this.values.get(t);
          return (
            void 0 === i &&
              void 0 !== e &&
              ((i = (0, ih.BX)(null === e ? void 0 : e, { owner: this })),
              this.addValue(t, i)),
            i
          );
        }
        readValue(t, e) {
          var i;
          let n =
            void 0 === this.latestValues[t] && this.current
              ? null !== (i = this.getBaseTargetFromProps(this.props, t)) &&
                void 0 !== i
                ? i
                : this.readValueFromInstance(this.current, t, this.options)
              : this.latestValues[t];
          return (
            null != n &&
              ("string" == typeof n && (t4(n) || t3(n))
                ? (n = parseFloat(n))
                : !rs(n) && ef.P.test(e) && (n = eP(t, e)),
              this.setBaseTarget(t, _(n) ? n.get() : n)),
            _(n) ? n.get() : n
          );
        }
        setBaseTarget(t, e) {
          this.baseTarget[t] = e;
        }
        getBaseTarget(t) {
          var e;
          let i;
          let { initial: n } = this.props;
          if ("string" == typeof n || "object" == typeof n) {
            let r = tl(
              this.props,
              n,
              null === (e = this.presenceContext) || void 0 === e
                ? void 0
                : e.custom
            );
            r && (i = r[t]);
          }
          if (n && void 0 !== i) return i;
          let r = this.getBaseTargetFromProps(this.props, t);
          return void 0 === r || _(r)
            ? void 0 !== this.initialValues[t] && void 0 === i
              ? void 0
              : this.baseTarget[t]
            : r;
        }
        on(t, e) {
          return (
            this.events[t] || (this.events[t] = new nh.L()),
            this.events[t].add(e)
          );
        }
        notify(t, ...e) {
          this.events[t] && this.events[t].notify(...e);
        }
      }
      class rd extends rh {
        constructor() {
          super(...arguments), (this.KeyframeResolver = eA);
        }
        sortInstanceNodePosition(t, e) {
          return 2 & t.compareDocumentPosition(e) ? 1 : -1;
        }
        getBaseTargetFromProps(t, e) {
          return t.style ? t.style[e] : void 0;
        }
        removeValueFromRenderState(t, { vars: e, style: i }) {
          delete e[t], delete i[t];
        }
      }
      class rp extends rd {
        constructor() {
          super(...arguments), (this.type = "html");
        }
        readValueFromInstance(t, e) {
          if (M.has(e)) {
            let t = eS(e);
            return (t && t.default) || 0;
          }
          {
            let i = window.getComputedStyle(t),
              n = ((0, B.f)(e) ? i.getPropertyValue(e) : i[e]) || 0;
            return "string" == typeof n ? n.trim() : n;
          }
        }
        measureInstanceViewportBox(t, { transformPagePoint: e }) {
          return i9(t, e);
        }
        build(t, e, i, n) {
          U(t, e, i, n.transformTemplate);
        }
        scrapeMotionValuesFromProps(t, e, i) {
          return to(t, e, i);
        }
        handleChildMotionValue() {
          this.childSubscription &&
            (this.childSubscription(), delete this.childSubscription);
          let { children: t } = this.props;
          _(t) &&
            (this.childSubscription = t.on("change", (t) => {
              this.current && (this.current.textContent = `${t}`);
            }));
        }
        renderInstance(t, e, i, n) {
          ti(t, e, i, n);
        }
      }
      class rf extends rd {
        constructor() {
          super(...arguments), (this.type = "svg"), (this.isSVGTag = !1);
        }
        getBaseTargetFromProps(t, e) {
          return t[e];
        }
        readValueFromInstance(t, e) {
          if (M.has(e)) {
            let t = eS(e);
            return (t && t.default) || 0;
          }
          return (e = tn.has(e) ? e : h(e)), t.getAttribute(e);
        }
        measureInstanceViewportBox() {
          return iH();
        }
        scrapeMotionValuesFromProps(t, e, i) {
          return ts(t, e, i);
        }
        build(t, e, i, n) {
          Q(t, e, i, this.isSVGTag, n.transformTemplate);
        }
        renderInstance(t, e, i, n) {
          tr(t, e, i, n);
        }
        mount(t) {
          (this.isSVGTag = te(t.tagName)), super.mount(t);
        }
      }
      let rm = (t, e) =>
          V(t)
            ? new rf(e, { enableHardwareAcceleration: !1 })
            : new rp(e, {
                allowProjection: t !== o.Fragment,
                enableHardwareAcceleration: !0,
              }),
        rv = {
          animation: { Feature: iw },
          exit: { Feature: iS },
          inView: { Feature: tN },
          tap: { Feature: tL },
          focus: { Feature: tD },
          hover: { Feature: tO },
          pan: { Feature: nr },
          drag: { Feature: ni, ProjectionNode: re, MeasureLayout: nu },
          layout: { ProjectionNode: re, MeasureLayout: nu },
        },
        ry = (function (t) {
          function e(e, i = {}) {
            return (function ({
              preloadedFeatures: t,
              createVisualElement: e,
              useRender: i,
              useVisualState: n,
              Component: h,
            }) {
              t &&
                (function (t) {
                  for (let e in t) T[e] = { ...T[e], ...t[e] };
                })(t);
              let f = (0, o.forwardRef)(function (f, y) {
                var g;
                let x;
                let b = {
                    ...(0, o.useContext)(s._),
                    ...f,
                    layoutId: (function ({ layoutId: t }) {
                      let e = (0, o.useContext)(E).id;
                      return e && void 0 !== t ? e + "-" + t : t;
                    })(f),
                  },
                  { isStatic: P } = b,
                  T = (function (t) {
                    let { initial: e, animate: i } = (function (t, e) {
                      if (w(t)) {
                        let { initial: e, animate: i } = t;
                        return {
                          initial: !1 === e || v(e) ? e : void 0,
                          animate: v(i) ? i : void 0,
                        };
                      }
                      return !1 !== t.inherit ? e : {};
                    })(t, (0, o.useContext)(a));
                    return (0, o.useMemo)(
                      () => ({ initial: e, animate: i }),
                      [S(e), S(i)]
                    );
                  })(f),
                  R = n(f, P);
                if (!P && A.j) {
                  T.visualElement = (function (t, e, i, n) {
                    let { visualElement: r } = (0, o.useContext)(a),
                      h = (0, o.useContext)(c),
                      f = (0, o.useContext)(l),
                      m = (0, o.useContext)(s._).reducedMotion,
                      v = (0, o.useRef)();
                    (n = n || h.renderer),
                      !v.current &&
                        n &&
                        (v.current = n(t, {
                          visualState: e,
                          parent: r,
                          props: i,
                          presenceContext: f,
                          blockInitialAnimation: !!f && !1 === f.initial,
                          reducedMotionConfig: m,
                        }));
                    let y = v.current;
                    (0, o.useInsertionEffect)(() => {
                      y && y.update(i, f);
                    });
                    let g = (0, o.useRef)(!!(i[d] && !window.HandoffComplete));
                    return (
                      (0, u.L)(() => {
                        y &&
                          (p.render(y.render),
                          g.current &&
                            y.animationState &&
                            y.animationState.animateChanges());
                      }),
                      (0, o.useEffect)(() => {
                        y &&
                          (y.updateFeatures(),
                          !g.current &&
                            y.animationState &&
                            y.animationState.animateChanges(),
                          g.current &&
                            ((g.current = !1), (window.HandoffComplete = !0)));
                      }),
                      y
                    );
                  })(h, R, b, e);
                  let i = (0, o.useContext)(C),
                    n = (0, o.useContext)(c).strict;
                  T.visualElement &&
                    (x = T.visualElement.loadFeatures(b, n, t, i));
                }
                return (0, r.jsxs)(a.Provider, {
                  value: T,
                  children: [
                    x && T.visualElement
                      ? (0, r.jsx)(x, { visualElement: T.visualElement, ...b })
                      : null,
                    i(
                      h,
                      f,
                      ((g = T.visualElement),
                      (0, o.useCallback)(
                        (t) => {
                          t && R.mount && R.mount(t),
                            g && (t ? g.mount(t) : g.unmount()),
                            y &&
                              ("function" == typeof y
                                ? y(t)
                                : m(y) && (y.current = t));
                        },
                        [g]
                      )),
                      R,
                      P,
                      T.visualElement
                    ),
                  ],
                });
              });
              return (f[R] = h), f;
            })(t(e, i));
          }
          if ("undefined" == typeof Proxy) return e;
          let i = new Map();
          return new Proxy(e, {
            get: (t, n) => (i.has(n) || i.set(n, e(n)), i.get(n)),
          });
        })((t, e) =>
          (function (t, { forwardMotionProps: e = !1 }, i, n) {
            return {
              ...(V(t) ? tv : ty),
              preloadedFeatures: i,
              useRender: (function (t = !1) {
                return (e, i, n, { latestValues: r }, s) => {
                  let a = (
                      V(e)
                        ? function (t, e, i, n) {
                            let r = (0, o.useMemo)(() => {
                              let i = tt();
                              return (
                                Q(
                                  i,
                                  e,
                                  { enableHardwareAcceleration: !1 },
                                  te(n),
                                  t.transformTemplate
                                ),
                                { ...i.attrs, style: { ...i.style } }
                              );
                            }, [e]);
                            if (t.style) {
                              let e = {};
                              X(e, t.style, t),
                                (r.style = { ...e, ...r.style });
                            }
                            return r;
                          }
                        : function (t, e, i) {
                            let n = {},
                              r = (function (t, e, i) {
                                let n = t.style || {},
                                  r = {};
                                return (
                                  X(r, n, t),
                                  Object.assign(
                                    r,
                                    (function ({ transformTemplate: t }, e, i) {
                                      return (0, o.useMemo)(() => {
                                        let n = H();
                                        return (
                                          U(
                                            n,
                                            e,
                                            { enableHardwareAcceleration: !i },
                                            t
                                          ),
                                          Object.assign({}, n.vars, n.style)
                                        );
                                      }, [e]);
                                    })(t, e, i)
                                  ),
                                  r
                                );
                              })(t, e, i);
                            return (
                              t.drag &&
                                !1 !== t.dragListener &&
                                ((n.draggable = !1),
                                (r.userSelect =
                                  r.WebkitUserSelect =
                                  r.WebkitTouchCallout =
                                    "none"),
                                (r.touchAction =
                                  !0 === t.drag
                                    ? "none"
                                    : `pan-${"x" === t.drag ? "y" : "x"}`)),
                              void 0 === t.tabIndex &&
                                (t.onTap || t.onTapStart || t.whileTap) &&
                                (n.tabIndex = 0),
                              (n.style = r),
                              n
                            );
                          }
                    )(i, r, s, e),
                    l = (function (t, e, i) {
                      let n = {};
                      for (let r in t)
                        ("values" !== r || "object" != typeof t.values) &&
                          (q(r) ||
                            (!0 === i && Y(r)) ||
                            (!e && !Y(r)) ||
                            (t.draggable && r.startsWith("onDrag"))) &&
                          (n[r] = t[r]);
                      return n;
                    })(i, "string" == typeof e, t),
                    u = e !== o.Fragment ? { ...l, ...a, ref: n } : {},
                    { children: c } = i,
                    h = (0, o.useMemo)(() => (_(c) ? c.get() : c), [c]);
                  return (0, o.createElement)(e, { ...u, children: h });
                };
              })(e),
              createVisualElement: n,
              Component: t,
            };
          })(t, e, rv, rm)
        );
    },
    1534: function (t, e, i) {
      "use strict";
      i.d(e, {
        f: function () {
          return r;
        },
        t: function () {
          return s;
        },
      });
      let n = (t) => (e) => "string" == typeof e && e.startsWith(t),
        r = n("--"),
        o = n("var(--"),
        s = (t) => !!o(t) && a.test(t.split("/*")[0].trim()),
        a =
          /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
    },
    565: function (t, e, i) {
      "use strict";
      i.d(e, {
        c: function () {
          return n;
        },
      });
      let n = { skipAnimations: !1, useManualTiming: !1 };
    },
    8746: function (t, e, i) {
      "use strict";
      function n(t, e) {
        -1 === t.indexOf(e) && t.push(e);
      }
      function r(t, e) {
        let i = t.indexOf(e);
        i > -1 && t.splice(i, 1);
      }
      i.d(e, {
        cl: function () {
          return r;
        },
        y4: function () {
          return n;
        },
      });
    },
    1506: function (t, e, i) {
      "use strict";
      i.d(e, {
        u: function () {
          return n;
        },
      });
      let n = (t, e, i) => (i > e ? e : i < t ? t : i);
    },
    9047: function (t, e, i) {
      "use strict";
      i.d(e, {
        K: function () {
          return r;
        },
        k: function () {
          return o;
        },
      });
      var n = i(9276);
      let r = n.Z,
        o = n.Z;
    },
    2548: function (t, e, i) {
      "use strict";
      i.d(e, {
        s: function () {
          return u;
        },
      });
      var n = i(9047),
        r = i(1506),
        o = i(9654),
        s = i(3217),
        a = i(9276),
        l = i(5389);
      function u(t, e, { clamp: i = !0, ease: u, mixer: c } = {}) {
        let h = t.length;
        if (
          ((0, n.k)(
            h === e.length,
            "Both input and output ranges must be the same length"
          ),
          1 === h)
        )
          return () => e[0];
        if (2 === h && t[0] === t[1]) return () => e[1];
        t[0] > t[h - 1] && ((t = [...t].reverse()), (e = [...e].reverse()));
        let d = (function (t, e, i) {
            let n = [],
              r = i || l.C,
              s = t.length - 1;
            for (let i = 0; i < s; i++) {
              let s = r(t[i], t[i + 1]);
              if (e) {
                let t = Array.isArray(e) ? e[i] || a.Z : e;
                s = (0, o.z)(t, s);
              }
              n.push(s);
            }
            return n;
          })(e, u, c),
          p = d.length,
          f = (e) => {
            let i = 0;
            if (p > 1) for (; i < t.length - 2 && !(e < t[i + 1]); i++);
            let n = (0, s.Y)(t[i], t[i + 1], e);
            return d[i](n);
          };
        return i ? (e) => f((0, r.u)(t[0], t[h - 1], e)) : f;
      }
    },
    7282: function (t, e, i) {
      "use strict";
      i.d(e, {
        j: function () {
          return n;
        },
      });
      let n = "undefined" != typeof document;
    },
    5389: function (t, e, i) {
      "use strict";
      i.d(e, {
        C: function () {
          return A;
        },
      });
      var n = i(5004),
        r = i(9047);
      function o(t, e, i) {
        return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6)
          ? t + (e - t) * 6 * i
          : i < 0.5
          ? e
          : i < 2 / 3
          ? t + (e - t) * (2 / 3 - i) * 6
          : t;
      }
      var s = i(5778),
        a = i(1583),
        l = i(598);
      function u(t, e) {
        return (i) => (i > 0 ? e : t);
      }
      let c = (t, e, i) => {
          let n = t * t,
            r = i * (e * e - n) + n;
          return r < 0 ? 0 : Math.sqrt(r);
        },
        h = [s.$, a.m, l.J],
        d = (t) => h.find((e) => e.test(t));
      function p(t) {
        let e = d(t);
        if (
          ((0, r.K)(
            !!e,
            `'${t}' is not an animatable color. Use the equivalent color code instead.`
          ),
          !e)
        )
          return !1;
        let i = e.parse(t);
        return (
          e === l.J &&
            (i = (function ({ hue: t, saturation: e, lightness: i, alpha: n }) {
              (t /= 360), (i /= 100);
              let r = 0,
                s = 0,
                a = 0;
              if ((e /= 100)) {
                let n = i < 0.5 ? i * (1 + e) : i + e - i * e,
                  l = 2 * i - n;
                (r = o(l, n, t + 1 / 3)),
                  (s = o(l, n, t)),
                  (a = o(l, n, t - 1 / 3));
              } else r = s = a = i;
              return {
                red: Math.round(255 * r),
                green: Math.round(255 * s),
                blue: Math.round(255 * a),
                alpha: n,
              };
            })(i)),
          i
        );
      }
      let f = (t, e) => {
        let i = p(t),
          r = p(e);
        if (!i || !r) return u(t, e);
        let o = { ...i };
        return (t) => (
          (o.red = c(i.red, r.red, t)),
          (o.green = c(i.green, r.green, t)),
          (o.blue = c(i.blue, r.blue, t)),
          (o.alpha = (0, n.t)(i.alpha, r.alpha, t)),
          a.m.transform(o)
        );
      };
      var m = i(9654),
        v = i(146),
        y = i(3646),
        g = i(1534);
      let x = new Set(["none", "hidden"]);
      function w(t, e) {
        return (i) => (0, n.t)(t, e, i);
      }
      function b(t) {
        return "number" == typeof t
          ? w
          : "string" == typeof t
          ? (0, g.t)(t)
            ? u
            : v.$.test(t)
            ? f
            : T
          : Array.isArray(t)
          ? S
          : "object" == typeof t
          ? v.$.test(t)
            ? f
            : P
          : u;
      }
      function S(t, e) {
        let i = [...t],
          n = i.length,
          r = t.map((t, i) => b(t)(t, e[i]));
        return (t) => {
          for (let e = 0; e < n; e++) i[e] = r[e](t);
          return i;
        };
      }
      function P(t, e) {
        let i = { ...t, ...e },
          n = {};
        for (let r in i)
          void 0 !== t[r] && void 0 !== e[r] && (n[r] = b(t[r])(t[r], e[r]));
        return (t) => {
          for (let e in n) i[e] = n[e](t);
          return i;
        };
      }
      let T = (t, e) => {
        let i = y.P.createTransformer(e),
          n = (0, y.V)(t),
          o = (0, y.V)(e);
        return n.indexes.var.length === o.indexes.var.length &&
          n.indexes.color.length === o.indexes.color.length &&
          n.indexes.number.length >= o.indexes.number.length
          ? (x.has(t) && !o.values.length) || (x.has(e) && !n.values.length)
            ? x.has(t)
              ? (i) => (i <= 0 ? t : e)
              : (i) => (i >= 1 ? e : t)
            : (0, m.z)(
                S(
                  (function (t, e) {
                    var i;
                    let n = [],
                      r = { color: 0, var: 0, number: 0 };
                    for (let o = 0; o < e.values.length; o++) {
                      let s = e.types[o],
                        a = t.indexes[s][r[s]],
                        l = null !== (i = t.values[a]) && void 0 !== i ? i : 0;
                      (n[o] = l), r[s]++;
                    }
                    return n;
                  })(n, o),
                  o.values
                ),
                i
              )
          : ((0, r.K)(
              !0,
              `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`
            ),
            u(t, e));
      };
      function A(t, e, i) {
        return "number" == typeof t &&
          "number" == typeof e &&
          "number" == typeof i
          ? (0, n.t)(t, e, i)
          : b(t)(t, e);
      }
    },
    5004: function (t, e, i) {
      "use strict";
      i.d(e, {
        t: function () {
          return n;
        },
      });
      let n = (t, e, i) => t + (e - t) * i;
    },
    9276: function (t, e, i) {
      "use strict";
      i.d(e, {
        Z: function () {
          return n;
        },
      });
      let n = (t) => t;
    },
    839: function (t, e, i) {
      "use strict";
      i.d(e, {
        Y: function () {
          return o;
        },
      });
      var n = i(5004),
        r = i(3217);
      function o(t) {
        let e = [0];
        return (
          !(function (t, e) {
            let i = t[t.length - 1];
            for (let o = 1; o <= e; o++) {
              let s = (0, r.Y)(0, e, o);
              t.push((0, n.t)(i, 1, s));
            }
          })(e, t.length - 1),
          e
        );
      }
    },
    9654: function (t, e, i) {
      "use strict";
      i.d(e, {
        z: function () {
          return r;
        },
      });
      let n = (t, e) => (i) => e(t(i)),
        r = (...t) => t.reduce(n);
    },
    3217: function (t, e, i) {
      "use strict";
      i.d(e, {
        Y: function () {
          return n;
        },
      });
      let n = (t, e, i) => {
        let n = e - t;
        return 0 === n ? 1 : (i - t) / n;
      };
    },
    2428: function (t, e, i) {
      "use strict";
      i.d(e, {
        L: function () {
          return r;
        },
      });
      var n = i(8746);
      class r {
        constructor() {
          this.subscriptions = [];
        }
        add(t) {
          return (
            (0, n.y4)(this.subscriptions, t),
            () => (0, n.cl)(this.subscriptions, t)
          );
        }
        notify(t, e, i) {
          let n = this.subscriptions.length;
          if (n) {
            if (1 === n) this.subscriptions[0](t, e, i);
            else
              for (let r = 0; r < n; r++) {
                let n = this.subscriptions[r];
                n && n(t, e, i);
              }
          }
        }
        getSize() {
          return this.subscriptions.length;
        }
        clear() {
          this.subscriptions.length = 0;
        }
      }
    },
    458: function (t, e, i) {
      "use strict";
      i.d(e, {
        h: function () {
          return r;
        },
      });
      var n = i(2265);
      function r(t) {
        let e = (0, n.useRef)(null);
        return null === e.current && (e.current = t()), e.current;
      }
    },
    9033: function (t, e, i) {
      "use strict";
      i.d(e, {
        L: function () {
          return r;
        },
      });
      var n = i(2265);
      let r = i(7282).j ? n.useLayoutEffect : n.useEffect;
    },
    3476: function (t, e, i) {
      "use strict";
      function n(t, e) {
        return e ? (1e3 / e) * t : 0;
      }
      i.d(e, {
        R: function () {
          return n;
        },
      });
    },
    804: function (t, e, i) {
      "use strict";
      i.d(e, {
        BX: function () {
          return c;
        },
        S1: function () {
          return l;
        },
      });
      var n = i(2428),
        r = i(3476),
        o = i(9993),
        s = i(6219);
      let a = (t) => !isNaN(parseFloat(t)),
        l = { current: void 0 };
      class u {
        constructor(t, e = {}) {
          (this.version = "11.2.10"),
            (this.canTrackVelocity = null),
            (this.events = {}),
            (this.updateAndNotify = (t, e = !0) => {
              let i = o.X.now();
              this.updatedAt !== i && this.setPrevFrameValue(),
                (this.prev = this.current),
                this.setCurrent(t),
                this.current !== this.prev &&
                  this.events.change &&
                  this.events.change.notify(this.current),
                e &&
                  this.events.renderRequest &&
                  this.events.renderRequest.notify(this.current);
            }),
            (this.hasAnimated = !1),
            this.setCurrent(t),
            (this.owner = e.owner);
        }
        setCurrent(t) {
          (this.current = t),
            (this.updatedAt = o.X.now()),
            null === this.canTrackVelocity &&
              void 0 !== t &&
              (this.canTrackVelocity = a(this.current));
        }
        setPrevFrameValue(t = this.current) {
          (this.prevFrameValue = t), (this.prevUpdatedAt = this.updatedAt);
        }
        onChange(t) {
          return this.on("change", t);
        }
        on(t, e) {
          this.events[t] || (this.events[t] = new n.L());
          let i = this.events[t].add(e);
          return "change" === t
            ? () => {
                i(),
                  s.Wi.read(() => {
                    this.events.change.getSize() || this.stop();
                  });
              }
            : i;
        }
        clearListeners() {
          for (let t in this.events) this.events[t].clear();
        }
        attach(t, e) {
          (this.passiveEffect = t), (this.stopPassiveEffect = e);
        }
        set(t, e = !0) {
          e && this.passiveEffect
            ? this.passiveEffect(t, this.updateAndNotify)
            : this.updateAndNotify(t, e);
        }
        setWithVelocity(t, e, i) {
          this.set(e),
            (this.prev = void 0),
            (this.prevFrameValue = t),
            (this.prevUpdatedAt = this.updatedAt - i);
        }
        jump(t, e = !0) {
          this.updateAndNotify(t),
            (this.prev = t),
            (this.prevUpdatedAt = this.prevFrameValue = void 0),
            e && this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
        }
        get() {
          return l.current && l.current.push(this), this.current;
        }
        getPrevious() {
          return this.prev;
        }
        getVelocity() {
          let t = o.X.now();
          if (
            !this.canTrackVelocity ||
            void 0 === this.prevFrameValue ||
            t - this.updatedAt > 30
          )
            return 0;
          let e = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
          return (0, r.R)(
            parseFloat(this.current) - parseFloat(this.prevFrameValue),
            e
          );
        }
        start(t) {
          return (
            this.stop(),
            new Promise((e) => {
              (this.hasAnimated = !0),
                (this.animation = t(e)),
                this.events.animationStart &&
                  this.events.animationStart.notify();
            }).then(() => {
              this.events.animationComplete &&
                this.events.animationComplete.notify(),
                this.clearAnimation();
            })
          );
        }
        stop() {
          this.animation &&
            (this.animation.stop(),
            this.events.animationCancel &&
              this.events.animationCancel.notify()),
            this.clearAnimation();
        }
        isAnimating() {
          return !!this.animation;
        }
        clearAnimation() {
          delete this.animation;
        }
        destroy() {
          this.clearListeners(),
            this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
        }
      }
      function c(t, e) {
        return new u(t, e);
      }
    },
    5778: function (t, e, i) {
      "use strict";
      i.d(e, {
        $: function () {
          return r;
        },
      });
      var n = i(1583);
      let r = {
        test: (0, i(3338).i)("#"),
        parse: function (t) {
          let e = "",
            i = "",
            n = "",
            r = "";
          return (
            t.length > 5
              ? ((e = t.substring(1, 3)),
                (i = t.substring(3, 5)),
                (n = t.substring(5, 7)),
                (r = t.substring(7, 9)))
              : ((e = t.substring(1, 2)),
                (i = t.substring(2, 3)),
                (n = t.substring(3, 4)),
                (r = t.substring(4, 5)),
                (e += e),
                (i += i),
                (n += n),
                (r += r)),
            {
              red: parseInt(e, 16),
              green: parseInt(i, 16),
              blue: parseInt(n, 16),
              alpha: r ? parseInt(r, 16) / 255 : 1,
            }
          );
        },
        transform: n.m.transform,
      };
    },
    598: function (t, e, i) {
      "use strict";
      i.d(e, {
        J: function () {
          return a;
        },
      });
      var n = i(783),
        r = i(5480),
        o = i(7292),
        s = i(3338);
      let a = {
        test: (0, s.i)("hsl", "hue"),
        parse: (0, s.d)("hue", "saturation", "lightness"),
        transform: ({ hue: t, saturation: e, lightness: i, alpha: s = 1 }) =>
          "hsla(" +
          Math.round(t) +
          ", " +
          r.aQ.transform((0, o.Nw)(e)) +
          ", " +
          r.aQ.transform((0, o.Nw)(i)) +
          ", " +
          (0, o.Nw)(n.Fq.transform(s)) +
          ")",
      };
    },
    146: function (t, e, i) {
      "use strict";
      i.d(e, {
        $: function () {
          return a;
        },
      });
      var n = i(7292),
        r = i(5778),
        o = i(598),
        s = i(1583);
      let a = {
        test: (t) => s.m.test(t) || r.$.test(t) || o.J.test(t),
        parse: (t) =>
          s.m.test(t)
            ? s.m.parse(t)
            : o.J.test(t)
            ? o.J.parse(t)
            : r.$.parse(t),
        transform: (t) =>
          (0, n.HD)(t)
            ? t
            : t.hasOwnProperty("red")
            ? s.m.transform(t)
            : o.J.transform(t),
      };
    },
    1583: function (t, e, i) {
      "use strict";
      i.d(e, {
        m: function () {
          return u;
        },
      });
      var n = i(1506),
        r = i(783),
        o = i(7292),
        s = i(3338);
      let a = (t) => (0, n.u)(0, 255, t),
        l = { ...r.Rx, transform: (t) => Math.round(a(t)) },
        u = {
          test: (0, s.i)("rgb", "red"),
          parse: (0, s.d)("red", "green", "blue"),
          transform: ({ red: t, green: e, blue: i, alpha: n = 1 }) =>
            "rgba(" +
            l.transform(t) +
            ", " +
            l.transform(e) +
            ", " +
            l.transform(i) +
            ", " +
            (0, o.Nw)(r.Fq.transform(n)) +
            ")",
        };
    },
    3338: function (t, e, i) {
      "use strict";
      i.d(e, {
        d: function () {
          return o;
        },
        i: function () {
          return r;
        },
      });
      var n = i(7292);
      let r = (t, e) => (i) =>
          !!(
            ((0, n.HD)(i) && n.mj.test(i) && i.startsWith(t)) ||
            (e && Object.prototype.hasOwnProperty.call(i, e))
          ),
        o = (t, e, i) => (r) => {
          if (!(0, n.HD)(r)) return r;
          let [o, s, a, l] = r.match(n.KP);
          return {
            [t]: parseFloat(o),
            [e]: parseFloat(s),
            [i]: parseFloat(a),
            alpha: void 0 !== l ? parseFloat(l) : 1,
          };
        };
    },
    3646: function (t, e, i) {
      "use strict";
      i.d(e, {
        P: function () {
          return d;
        },
        V: function () {
          return l;
        },
      });
      var n = i(146),
        r = i(7292);
      let o = "number",
        s = "color",
        a =
          /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
      function l(t) {
        let e = t.toString(),
          i = [],
          r = { color: [], number: [], var: [] },
          l = [],
          u = 0,
          c = e
            .replace(
              a,
              (t) => (
                n.$.test(t)
                  ? (r.color.push(u), l.push(s), i.push(n.$.parse(t)))
                  : t.startsWith("var(")
                  ? (r.var.push(u), l.push("var"), i.push(t))
                  : (r.number.push(u), l.push(o), i.push(parseFloat(t))),
                ++u,
                "${}"
              )
            )
            .split("${}");
        return { values: i, split: c, indexes: r, types: l };
      }
      function u(t) {
        return l(t).values;
      }
      function c(t) {
        let { split: e, types: i } = l(t),
          a = e.length;
        return (t) => {
          let l = "";
          for (let u = 0; u < a; u++)
            if (((l += e[u]), void 0 !== t[u])) {
              let e = i[u];
              e === o
                ? (l += (0, r.Nw)(t[u]))
                : e === s
                ? (l += n.$.transform(t[u]))
                : (l += t[u]);
            }
          return l;
        };
      }
      let h = (t) => ("number" == typeof t ? 0 : t),
        d = {
          test: function (t) {
            var e, i;
            return (
              isNaN(t) &&
              (0, r.HD)(t) &&
              ((null === (e = t.match(r.KP)) || void 0 === e
                ? void 0
                : e.length) || 0) +
                ((null === (i = t.match(r.dA)) || void 0 === i
                  ? void 0
                  : i.length) || 0) >
                0
            );
          },
          parse: u,
          createTransformer: c,
          getAnimatableNone: function (t) {
            let e = u(t);
            return c(t)(e.map(h));
          },
        };
    },
    783: function (t, e, i) {
      "use strict";
      i.d(e, {
        Fq: function () {
          return o;
        },
        Rx: function () {
          return r;
        },
        bA: function () {
          return s;
        },
      });
      var n = i(1506);
      let r = {
          test: (t) => "number" == typeof t,
          parse: parseFloat,
          transform: (t) => t,
        },
        o = { ...r, transform: (t) => (0, n.u)(0, 1, t) },
        s = { ...r, default: 1 };
    },
    5480: function (t, e, i) {
      "use strict";
      i.d(e, {
        $C: function () {
          return c;
        },
        RW: function () {
          return o;
        },
        aQ: function () {
          return s;
        },
        px: function () {
          return a;
        },
        vh: function () {
          return l;
        },
        vw: function () {
          return u;
        },
      });
      var n = i(7292);
      let r = (t) => ({
          test: (e) =>
            (0, n.HD)(e) && e.endsWith(t) && 1 === e.split(" ").length,
          parse: parseFloat,
          transform: (e) => `${e}${t}`,
        }),
        o = r("deg"),
        s = r("%"),
        a = r("px"),
        l = r("vh"),
        u = r("vw"),
        c = {
          ...s,
          parse: (t) => s.parse(t) / 100,
          transform: (t) => s.transform(100 * t),
        };
    },
    7292: function (t, e, i) {
      "use strict";
      i.d(e, {
        HD: function () {
          return a;
        },
        KP: function () {
          return r;
        },
        Nw: function () {
          return n;
        },
        dA: function () {
          return o;
        },
        mj: function () {
          return s;
        },
      });
      let n = (t) => Math.round(1e5 * t) / 1e5,
        r = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
        o =
          /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
        s =
          /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
      function a(t) {
        return "string" == typeof t;
      }
    },
    3473: function (t, e, i) {
      "use strict";
      i.d(e, {
        YD: function () {
          return u;
        },
      });
      var n = i(2265),
        r = Object.defineProperty,
        o = new Map(),
        s = new WeakMap(),
        a = 0,
        l = void 0;
      function u() {
        var t;
        let {
            threshold: e,
            delay: i,
            trackVisibility: r,
            rootMargin: u,
            root: c,
            triggerOnce: h,
            skip: d,
            initialInView: p,
            fallbackInView: f,
            onChange: m,
          } = arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : {},
          [v, y] = n.useState(null),
          g = n.useRef(),
          [x, w] = n.useState({ inView: !!p, entry: void 0 });
        (g.current = m),
          n.useEffect(() => {
            let t;
            if (!d && v)
              return (
                (t = (function (t, e) {
                  let i =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : {},
                    n =
                      arguments.length > 3 && void 0 !== arguments[3]
                        ? arguments[3]
                        : l;
                  if (void 0 === window.IntersectionObserver && void 0 !== n) {
                    let r = t.getBoundingClientRect();
                    return (
                      e(n, {
                        isIntersecting: n,
                        target: t,
                        intersectionRatio:
                          "number" == typeof i.threshold ? i.threshold : 0,
                        time: 0,
                        boundingClientRect: r,
                        intersectionRect: r,
                        rootBounds: r,
                      }),
                      () => {}
                    );
                  }
                  let {
                      id: r,
                      observer: u,
                      elements: c,
                    } = (function (t) {
                      let e = Object.keys(t)
                          .sort()
                          .filter((e) => void 0 !== t[e])
                          .map((e) => {
                            var i;
                            return ""
                              .concat(e, "_")
                              .concat(
                                "root" === e
                                  ? (i = t.root)
                                    ? (s.has(i) ||
                                        ((a += 1), s.set(i, a.toString())),
                                      s.get(i))
                                    : "0"
                                  : t[e]
                              );
                          })
                          .toString(),
                        i = o.get(e);
                      if (!i) {
                        let n;
                        let r = new Map(),
                          s = new IntersectionObserver((e) => {
                            e.forEach((e) => {
                              var i;
                              let o =
                                e.isIntersecting &&
                                n.some((t) => e.intersectionRatio >= t);
                              t.trackVisibility &&
                                void 0 === e.isVisible &&
                                (e.isVisible = o),
                                null == (i = r.get(e.target)) ||
                                  i.forEach((t) => {
                                    t(o, e);
                                  });
                            });
                          }, t);
                        (n =
                          s.thresholds ||
                          (Array.isArray(t.threshold)
                            ? t.threshold
                            : [t.threshold || 0])),
                          (i = { id: e, observer: s, elements: r }),
                          o.set(e, i);
                      }
                      return i;
                    })(i),
                    h = c.get(t) || [];
                  return (
                    c.has(t) || c.set(t, h),
                    h.push(e),
                    u.observe(t),
                    function () {
                      h.splice(h.indexOf(e), 1),
                        0 === h.length && (c.delete(t), u.unobserve(t)),
                        0 === c.size && (u.disconnect(), o.delete(r));
                    }
                  );
                })(
                  v,
                  (e, i) => {
                    w({ inView: e, entry: i }),
                      g.current && g.current(e, i),
                      i.isIntersecting && h && t && (t(), (t = void 0));
                  },
                  {
                    root: c,
                    rootMargin: u,
                    threshold: e,
                    trackVisibility: r,
                    delay: i,
                  },
                  f
                )),
                () => {
                  t && t();
                }
              );
          }, [Array.isArray(e) ? e.toString() : e, v, c, u, h, d, r, f, i]);
        let b = null == (t = x.entry) ? void 0 : t.target,
          S = n.useRef();
        v ||
          !b ||
          h ||
          d ||
          S.current === b ||
          ((S.current = b), w({ inView: !!p, entry: void 0 }));
        let P = [y, x.inView, x.entry];
        return (P.ref = P[0]), (P.inView = P[1]), (P.entry = P[2]), P;
      }
      n.Component;
    },
    6408: function (t, e, i) {
      "use strict";
      i.d(e, {
        u: function () {
          return tA;
        },
      });
      var n = i(2265);
      let r = Math.min,
        o = Math.max,
        s = Math.round,
        a = Math.floor,
        l = (t) => ({ x: t, y: t }),
        u = { left: "right", right: "left", bottom: "top", top: "bottom" },
        c = { start: "end", end: "start" };
      function h(t, e) {
        return "function" == typeof t ? t(e) : t;
      }
      function d(t) {
        return t.split("-")[0];
      }
      function p(t) {
        return t.split("-")[1];
      }
      function f(t) {
        return "x" === t ? "y" : "x";
      }
      function m(t) {
        return "y" === t ? "height" : "width";
      }
      function v(t) {
        return ["top", "bottom"].includes(d(t)) ? "y" : "x";
      }
      function y(t) {
        return t.replace(/start|end/g, (t) => c[t]);
      }
      function g(t) {
        return t.replace(/left|right|bottom|top/g, (t) => u[t]);
      }
      function x(t) {
        return "number" != typeof t
          ? { top: 0, right: 0, bottom: 0, left: 0, ...t }
          : { top: t, right: t, bottom: t, left: t };
      }
      function w(t) {
        let { x: e, y: i, width: n, height: r } = t;
        return {
          width: n,
          height: r,
          top: i,
          left: e,
          right: e + n,
          bottom: i + r,
          x: e,
          y: i,
        };
      }
      function b(t, e, i) {
        let n,
          { reference: r, floating: o } = t,
          s = v(e),
          a = f(v(e)),
          l = m(a),
          u = d(e),
          c = "y" === s,
          h = r.x + r.width / 2 - o.width / 2,
          y = r.y + r.height / 2 - o.height / 2,
          g = r[l] / 2 - o[l] / 2;
        switch (u) {
          case "top":
            n = { x: h, y: r.y - o.height };
            break;
          case "bottom":
            n = { x: h, y: r.y + r.height };
            break;
          case "right":
            n = { x: r.x + r.width, y: y };
            break;
          case "left":
            n = { x: r.x - o.width, y: y };
            break;
          default:
            n = { x: r.x, y: r.y };
        }
        switch (p(e)) {
          case "start":
            n[a] -= g * (i && c ? -1 : 1);
            break;
          case "end":
            n[a] += g * (i && c ? -1 : 1);
        }
        return n;
      }
      let S = async (t, e, i) => {
        let {
            placement: n = "bottom",
            strategy: r = "absolute",
            middleware: o = [],
            platform: s,
          } = i,
          a = o.filter(Boolean),
          l = await (null == s.isRTL ? void 0 : s.isRTL(e)),
          u = await s.getElementRects({
            reference: t,
            floating: e,
            strategy: r,
          }),
          { x: c, y: h } = b(u, n, l),
          d = n,
          p = {},
          f = 0;
        for (let i = 0; i < a.length; i++) {
          let { name: o, fn: m } = a[i],
            {
              x: v,
              y: y,
              data: g,
              reset: x,
            } = await m({
              x: c,
              y: h,
              initialPlacement: n,
              placement: d,
              strategy: r,
              middlewareData: p,
              rects: u,
              platform: s,
              elements: { reference: t, floating: e },
            });
          (c = null != v ? v : c),
            (h = null != y ? y : h),
            (p = { ...p, [o]: { ...p[o], ...g } }),
            x &&
              f <= 50 &&
              (f++,
              "object" == typeof x &&
                (x.placement && (d = x.placement),
                x.rects &&
                  (u =
                    !0 === x.rects
                      ? await s.getElementRects({
                          reference: t,
                          floating: e,
                          strategy: r,
                        })
                      : x.rects),
                ({ x: c, y: h } = b(u, d, l))),
              (i = -1));
        }
        return { x: c, y: h, placement: d, strategy: r, middlewareData: p };
      };
      async function P(t, e) {
        var i;
        void 0 === e && (e = {});
        let { x: n, y: r, platform: o, rects: s, elements: a, strategy: l } = t,
          {
            boundary: u = "clippingAncestors",
            rootBoundary: c = "viewport",
            elementContext: d = "floating",
            altBoundary: p = !1,
            padding: f = 0,
          } = h(e, t),
          m = x(f),
          v = a[p ? ("floating" === d ? "reference" : "floating") : d],
          y = w(
            await o.getClippingRect({
              element:
                null ==
                  (i = await (null == o.isElement ? void 0 : o.isElement(v))) ||
                i
                  ? v
                  : v.contextElement ||
                    (await (null == o.getDocumentElement
                      ? void 0
                      : o.getDocumentElement(a.floating))),
              boundary: u,
              rootBoundary: c,
              strategy: l,
            })
          ),
          g =
            "floating" === d
              ? {
                  x: n,
                  y: r,
                  width: s.floating.width,
                  height: s.floating.height,
                }
              : s.reference,
          b = await (null == o.getOffsetParent
            ? void 0
            : o.getOffsetParent(a.floating)),
          S = ((await (null == o.isElement ? void 0 : o.isElement(b))) &&
            (await (null == o.getScale ? void 0 : o.getScale(b)))) || {
            x: 1,
            y: 1,
          },
          P = w(
            o.convertOffsetParentRelativeRectToViewportRelativeRect
              ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
                  elements: a,
                  rect: g,
                  offsetParent: b,
                  strategy: l,
                })
              : g
          );
        return {
          top: (y.top - P.top + m.top) / S.y,
          bottom: (P.bottom - y.bottom + m.bottom) / S.y,
          left: (y.left - P.left + m.left) / S.x,
          right: (P.right - y.right + m.right) / S.x,
        };
      }
      async function T(t, e) {
        let { placement: i, platform: n, elements: r } = t,
          o = await (null == n.isRTL ? void 0 : n.isRTL(r.floating)),
          s = d(i),
          a = p(i),
          l = "y" === v(i),
          u = ["left", "top"].includes(s) ? -1 : 1,
          c = o && l ? -1 : 1,
          f = h(e, t),
          {
            mainAxis: m,
            crossAxis: y,
            alignmentAxis: g,
          } = "number" == typeof f
            ? { mainAxis: f, crossAxis: 0, alignmentAxis: null }
            : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...f };
        return (
          a && "number" == typeof g && (y = "end" === a ? -1 * g : g),
          l ? { x: y * c, y: m * u } : { x: m * u, y: y * c }
        );
      }
      function A(t) {
        return R(t) ? (t.nodeName || "").toLowerCase() : "#document";
      }
      function E(t) {
        var e;
        return (
          (null == t || null == (e = t.ownerDocument)
            ? void 0
            : e.defaultView) || window
        );
      }
      function C(t) {
        var e;
        return null ==
          (e = (R(t) ? t.ownerDocument : t.document) || window.document)
          ? void 0
          : e.documentElement;
      }
      function R(t) {
        return t instanceof Node || t instanceof E(t).Node;
      }
      function k(t) {
        return t instanceof Element || t instanceof E(t).Element;
      }
      function V(t) {
        return t instanceof HTMLElement || t instanceof E(t).HTMLElement;
      }
      function O(t) {
        return (
          "undefined" != typeof ShadowRoot &&
          (t instanceof ShadowRoot || t instanceof E(t).ShadowRoot)
        );
      }
      function D(t) {
        let { overflow: e, overflowX: i, overflowY: n, display: r } = L(t);
        return (
          /auto|scroll|overlay|hidden|clip/.test(e + n + i) &&
          !["inline", "contents"].includes(r)
        );
      }
      function M(t) {
        let e = j(),
          i = L(t);
        return (
          "none" !== i.transform ||
          "none" !== i.perspective ||
          (!!i.containerType && "normal" !== i.containerType) ||
          (!e && !!i.backdropFilter && "none" !== i.backdropFilter) ||
          (!e && !!i.filter && "none" !== i.filter) ||
          ["transform", "perspective", "filter"].some((t) =>
            (i.willChange || "").includes(t)
          ) ||
          ["paint", "layout", "strict", "content"].some((t) =>
            (i.contain || "").includes(t)
          )
        );
      }
      function j() {
        return (
          "undefined" != typeof CSS &&
          !!CSS.supports &&
          CSS.supports("-webkit-backdrop-filter", "none")
        );
      }
      function _(t) {
        return ["html", "body", "#document"].includes(A(t));
      }
      function L(t) {
        return E(t).getComputedStyle(t);
      }
      function F(t) {
        return k(t)
          ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
          : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
      }
      function B(t) {
        if ("html" === A(t)) return t;
        let e = t.assignedSlot || t.parentNode || (O(t) && t.host) || C(t);
        return O(e) ? e.host : e;
      }
      function I(t, e, i) {
        var n;
        void 0 === e && (e = []), void 0 === i && (i = !0);
        let r = (function t(e) {
            let i = B(e);
            return _(i)
              ? e.ownerDocument
                ? e.ownerDocument.body
                : e.body
              : V(i) && D(i)
              ? i
              : t(i);
          })(t),
          o = r === (null == (n = t.ownerDocument) ? void 0 : n.body),
          s = E(r);
        return o
          ? e.concat(
              s,
              s.visualViewport || [],
              D(r) ? r : [],
              s.frameElement && i ? I(s.frameElement) : []
            )
          : e.concat(r, I(r, [], i));
      }
      function $(t) {
        let e = L(t),
          i = parseFloat(e.width) || 0,
          n = parseFloat(e.height) || 0,
          r = V(t),
          o = r ? t.offsetWidth : i,
          a = r ? t.offsetHeight : n,
          l = s(i) !== o || s(n) !== a;
        return l && ((i = o), (n = a)), { width: i, height: n, $: l };
      }
      function W(t) {
        return k(t) ? t : t.contextElement;
      }
      function N(t) {
        let e = W(t);
        if (!V(e)) return l(1);
        let i = e.getBoundingClientRect(),
          { width: n, height: r, $: o } = $(e),
          a = (o ? s(i.width) : i.width) / n,
          u = (o ? s(i.height) : i.height) / r;
        return (
          (a && Number.isFinite(a)) || (a = 1),
          (u && Number.isFinite(u)) || (u = 1),
          { x: a, y: u }
        );
      }
      let z = l(0);
      function U(t) {
        let e = E(t);
        return j() && e.visualViewport
          ? { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop }
          : z;
      }
      function H(t, e, i, n) {
        var r;
        void 0 === e && (e = !1), void 0 === i && (i = !1);
        let o = t.getBoundingClientRect(),
          s = W(t),
          a = l(1);
        e && (n ? k(n) && (a = N(n)) : (a = N(t)));
        let u = (void 0 === (r = i) && (r = !1), n && (!r || n === E(s)) && r)
            ? U(s)
            : l(0),
          c = (o.left + u.x) / a.x,
          h = (o.top + u.y) / a.y,
          d = o.width / a.x,
          p = o.height / a.y;
        if (s) {
          let t = E(s),
            e = n && k(n) ? E(n) : n,
            i = t,
            r = i.frameElement;
          for (; r && n && e !== i; ) {
            let t = N(r),
              e = r.getBoundingClientRect(),
              n = L(r),
              o = e.left + (r.clientLeft + parseFloat(n.paddingLeft)) * t.x,
              s = e.top + (r.clientTop + parseFloat(n.paddingTop)) * t.y;
            (c *= t.x),
              (h *= t.y),
              (d *= t.x),
              (p *= t.y),
              (c += o),
              (h += s),
              (r = (i = E(r)).frameElement);
          }
        }
        return w({ width: d, height: p, x: c, y: h });
      }
      let X = [":popover-open", ":modal"];
      function K(t) {
        return X.some((e) => {
          try {
            return t.matches(e);
          } catch (t) {
            return !1;
          }
        });
      }
      function Y(t) {
        return H(C(t)).left + F(t).scrollLeft;
      }
      function q(t, e, i) {
        let n;
        if ("viewport" === e)
          n = (function (t, e) {
            let i = E(t),
              n = C(t),
              r = i.visualViewport,
              o = n.clientWidth,
              s = n.clientHeight,
              a = 0,
              l = 0;
            if (r) {
              (o = r.width), (s = r.height);
              let t = j();
              (!t || (t && "fixed" === e)) &&
                ((a = r.offsetLeft), (l = r.offsetTop));
            }
            return { width: o, height: s, x: a, y: l };
          })(t, i);
        else if ("document" === e)
          n = (function (t) {
            let e = C(t),
              i = F(t),
              n = t.ownerDocument.body,
              r = o(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth),
              s = o(
                e.scrollHeight,
                e.clientHeight,
                n.scrollHeight,
                n.clientHeight
              ),
              a = -i.scrollLeft + Y(t),
              l = -i.scrollTop;
            return (
              "rtl" === L(n).direction &&
                (a += o(e.clientWidth, n.clientWidth) - r),
              { width: r, height: s, x: a, y: l }
            );
          })(C(t));
        else if (k(e))
          n = (function (t, e) {
            let i = H(t, !0, "fixed" === e),
              n = i.top + t.clientTop,
              r = i.left + t.clientLeft,
              o = V(t) ? N(t) : l(1),
              s = t.clientWidth * o.x;
            return {
              width: s,
              height: t.clientHeight * o.y,
              x: r * o.x,
              y: n * o.y,
            };
          })(e, i);
        else {
          let i = U(t);
          n = { ...e, x: e.x - i.x, y: e.y - i.y };
        }
        return w(n);
      }
      function Z(t) {
        return "static" === L(t).position;
      }
      function G(t, e) {
        return V(t) && "fixed" !== L(t).position
          ? e
            ? e(t)
            : t.offsetParent
          : null;
      }
      function J(t, e) {
        let i = E(t);
        if (K(t)) return i;
        if (!V(t)) {
          let e = B(t);
          for (; e && !_(e); ) {
            if (k(e) && !Z(e)) return e;
            e = B(e);
          }
          return i;
        }
        let n = G(t, e);
        for (; n && ["table", "td", "th"].includes(A(n)) && Z(n); ) n = G(n, e);
        return n && _(n) && Z(n) && !M(n)
          ? i
          : n ||
              (function (t) {
                let e = B(t);
                for (; V(e) && !_(e); ) {
                  if (M(e)) return e;
                  e = B(e);
                }
                return null;
              })(t) ||
              i;
      }
      let Q = async function (t) {
          let e = this.getOffsetParent || J,
            i = this.getDimensions,
            n = await i(t.floating);
          return {
            reference: (function (t, e, i) {
              let n = V(e),
                r = C(e),
                o = "fixed" === i,
                s = H(t, !0, o, e),
                a = { scrollLeft: 0, scrollTop: 0 },
                u = l(0);
              if (n || (!n && !o)) {
                if ((("body" !== A(e) || D(r)) && (a = F(e)), n)) {
                  let t = H(e, !0, o, e);
                  (u.x = t.x + e.clientLeft), (u.y = t.y + e.clientTop);
                } else r && (u.x = Y(r));
              }
              return {
                x: s.left + a.scrollLeft - u.x,
                y: s.top + a.scrollTop - u.y,
                width: s.width,
                height: s.height,
              };
            })(t.reference, await e(t.floating), t.strategy),
            floating: { x: 0, y: 0, width: n.width, height: n.height },
          };
        },
        tt = {
          convertOffsetParentRelativeRectToViewportRelativeRect: function (t) {
            let { elements: e, rect: i, offsetParent: n, strategy: r } = t,
              o = "fixed" === r,
              s = C(n),
              a = !!e && K(e.floating);
            if (n === s || (a && o)) return i;
            let u = { scrollLeft: 0, scrollTop: 0 },
              c = l(1),
              h = l(0),
              d = V(n);
            if (
              (d || (!d && !o)) &&
              (("body" !== A(n) || D(s)) && (u = F(n)), V(n))
            ) {
              let t = H(n);
              (c = N(n)), (h.x = t.x + n.clientLeft), (h.y = t.y + n.clientTop);
            }
            return {
              width: i.width * c.x,
              height: i.height * c.y,
              x: i.x * c.x - u.scrollLeft * c.x + h.x,
              y: i.y * c.y - u.scrollTop * c.y + h.y,
            };
          },
          getDocumentElement: C,
          getClippingRect: function (t) {
            let { element: e, boundary: i, rootBoundary: n, strategy: s } = t,
              a = [
                ...("clippingAncestors" === i
                  ? K(e)
                    ? []
                    : (function (t, e) {
                        let i = e.get(t);
                        if (i) return i;
                        let n = I(t, [], !1).filter(
                            (t) => k(t) && "body" !== A(t)
                          ),
                          r = null,
                          o = "fixed" === L(t).position,
                          s = o ? B(t) : t;
                        for (; k(s) && !_(s); ) {
                          let e = L(s),
                            i = M(s);
                          i || "fixed" !== e.position || (r = null),
                            (
                              o
                                ? !i && !r
                                : (!i &&
                                    "static" === e.position &&
                                    !!r &&
                                    ["absolute", "fixed"].includes(
                                      r.position
                                    )) ||
                                  (D(s) &&
                                    !i &&
                                    (function t(e, i) {
                                      let n = B(e);
                                      return (
                                        !(n === i || !k(n) || _(n)) &&
                                        ("fixed" === L(n).position || t(n, i))
                                      );
                                    })(t, s))
                            )
                              ? (n = n.filter((t) => t !== s))
                              : (r = e),
                            (s = B(s));
                        }
                        return e.set(t, n), n;
                      })(e, this._c)
                  : [].concat(i)),
                n,
              ],
              l = a[0],
              u = a.reduce((t, i) => {
                let n = q(e, i, s);
                return (
                  (t.top = o(n.top, t.top)),
                  (t.right = r(n.right, t.right)),
                  (t.bottom = r(n.bottom, t.bottom)),
                  (t.left = o(n.left, t.left)),
                  t
                );
              }, q(e, l, s));
            return {
              width: u.right - u.left,
              height: u.bottom - u.top,
              x: u.left,
              y: u.top,
            };
          },
          getOffsetParent: J,
          getElementRects: Q,
          getClientRects: function (t) {
            return Array.from(t.getClientRects());
          },
          getDimensions: function (t) {
            let { width: e, height: i } = $(t);
            return { width: e, height: i };
          },
          getScale: N,
          isElement: k,
          isRTL: function (t) {
            return "rtl" === L(t).direction;
          },
        },
        te = function (t) {
          return (
            void 0 === t && (t = 0),
            {
              name: "offset",
              options: t,
              async fn(e) {
                var i, n;
                let { x: r, y: o, placement: s, middlewareData: a } = e,
                  l = await T(e, t);
                return s === (null == (i = a.offset) ? void 0 : i.placement) &&
                  null != (n = a.arrow) &&
                  n.alignmentOffset
                  ? {}
                  : { x: r + l.x, y: o + l.y, data: { ...l, placement: s } };
              },
            }
          );
        },
        ti = function (t) {
          return (
            void 0 === t && (t = {}),
            {
              name: "shift",
              options: t,
              async fn(e) {
                let { x: i, y: n, placement: s } = e,
                  {
                    mainAxis: a = !0,
                    crossAxis: l = !1,
                    limiter: u = {
                      fn: (t) => {
                        let { x: e, y: i } = t;
                        return { x: e, y: i };
                      },
                    },
                    ...c
                  } = h(t, e),
                  p = { x: i, y: n },
                  m = await P(e, c),
                  y = v(d(s)),
                  g = f(y),
                  x = p[g],
                  w = p[y];
                if (a) {
                  let t = "y" === g ? "top" : "left",
                    e = "y" === g ? "bottom" : "right",
                    i = x + m[t],
                    n = x - m[e];
                  x = o(i, r(x, n));
                }
                if (l) {
                  let t = "y" === y ? "top" : "left",
                    e = "y" === y ? "bottom" : "right",
                    i = w + m[t],
                    n = w - m[e];
                  w = o(i, r(w, n));
                }
                let b = u.fn({ ...e, [g]: x, [y]: w });
                return { ...b, data: { x: b.x - i, y: b.y - n } };
              },
            }
          );
        },
        tn = function (t) {
          return (
            void 0 === t && (t = {}),
            {
              name: "flip",
              options: t,
              async fn(e) {
                var i, n, r, o, s;
                let {
                    placement: a,
                    middlewareData: l,
                    rects: u,
                    initialPlacement: c,
                    platform: x,
                    elements: w,
                  } = e,
                  {
                    mainAxis: b = !0,
                    crossAxis: S = !0,
                    fallbackPlacements: T,
                    fallbackStrategy: A = "bestFit",
                    fallbackAxisSideDirection: E = "none",
                    flipAlignment: C = !0,
                    ...R
                  } = h(t, e);
                if (null != (i = l.arrow) && i.alignmentOffset) return {};
                let k = d(a),
                  V = d(c) === c,
                  O = await (null == x.isRTL ? void 0 : x.isRTL(w.floating)),
                  D =
                    T ||
                    (V || !C
                      ? [g(c)]
                      : (function (t) {
                          let e = g(t);
                          return [y(t), e, y(e)];
                        })(c));
                T ||
                  "none" === E ||
                  D.push(
                    ...(function (t, e, i, n) {
                      let r = p(t),
                        o = (function (t, e, i) {
                          let n = ["left", "right"],
                            r = ["right", "left"];
                          switch (t) {
                            case "top":
                            case "bottom":
                              if (i) return e ? r : n;
                              return e ? n : r;
                            case "left":
                            case "right":
                              return e ? ["top", "bottom"] : ["bottom", "top"];
                            default:
                              return [];
                          }
                        })(d(t), "start" === i, n);
                      return (
                        r &&
                          ((o = o.map((t) => t + "-" + r)),
                          e && (o = o.concat(o.map(y)))),
                        o
                      );
                    })(c, C, E, O)
                  );
                let M = [c, ...D],
                  j = await P(e, R),
                  _ = [],
                  L = (null == (n = l.flip) ? void 0 : n.overflows) || [];
                if ((b && _.push(j[k]), S)) {
                  let t = (function (t, e, i) {
                    void 0 === i && (i = !1);
                    let n = p(t),
                      r = f(v(t)),
                      o = m(r),
                      s =
                        "x" === r
                          ? n === (i ? "end" : "start")
                            ? "right"
                            : "left"
                          : "start" === n
                          ? "bottom"
                          : "top";
                    return (
                      e.reference[o] > e.floating[o] && (s = g(s)), [s, g(s)]
                    );
                  })(a, u, O);
                  _.push(j[t[0]], j[t[1]]);
                }
                if (
                  ((L = [...L, { placement: a, overflows: _ }]),
                  !_.every((t) => t <= 0))
                ) {
                  let t = ((null == (r = l.flip) ? void 0 : r.index) || 0) + 1,
                    e = M[t];
                  if (e)
                    return {
                      data: { index: t, overflows: L },
                      reset: { placement: e },
                    };
                  let i =
                    null ==
                    (o = L.filter((t) => t.overflows[0] <= 0).sort(
                      (t, e) => t.overflows[1] - e.overflows[1]
                    )[0])
                      ? void 0
                      : o.placement;
                  if (!i)
                    switch (A) {
                      case "bestFit": {
                        let t =
                          null ==
                          (s = L.map((t) => [
                            t.placement,
                            t.overflows
                              .filter((t) => t > 0)
                              .reduce((t, e) => t + e, 0),
                          ]).sort((t, e) => t[1] - e[1])[0])
                            ? void 0
                            : s[0];
                        t && (i = t);
                        break;
                      }
                      case "initialPlacement":
                        i = c;
                    }
                  if (a !== i) return { reset: { placement: i } };
                }
                return {};
              },
            }
          );
        },
        tr = (t) => ({
          name: "arrow",
          options: t,
          async fn(e) {
            let {
                x: i,
                y: n,
                placement: s,
                rects: a,
                platform: l,
                elements: u,
                middlewareData: c,
              } = e,
              { element: d, padding: y = 0 } = h(t, e) || {};
            if (null == d) return {};
            let g = x(y),
              w = { x: i, y: n },
              b = f(v(s)),
              S = m(b),
              P = await l.getDimensions(d),
              T = "y" === b,
              A = T ? "clientHeight" : "clientWidth",
              E = a.reference[S] + a.reference[b] - w[b] - a.floating[S],
              C = w[b] - a.reference[b],
              R = await (null == l.getOffsetParent
                ? void 0
                : l.getOffsetParent(d)),
              k = R ? R[A] : 0;
            (k && (await (null == l.isElement ? void 0 : l.isElement(R)))) ||
              (k = u.floating[A] || a.floating[S]);
            let V = k / 2 - P[S] / 2 - 1,
              O = r(g[T ? "top" : "left"], V),
              D = r(g[T ? "bottom" : "right"], V),
              M = k - P[S] - D,
              j = k / 2 - P[S] / 2 + (E / 2 - C / 2),
              _ = o(O, r(j, M)),
              L =
                !c.arrow &&
                null != p(s) &&
                j !== _ &&
                a.reference[S] / 2 - (j < O ? O : D) - P[S] / 2 < 0,
              F = L ? (j < O ? j - O : j - M) : 0;
            return {
              [b]: w[b] + F,
              data: {
                [b]: _,
                centerOffset: j - _ - F,
                ...(L && { alignmentOffset: F }),
              },
              reset: L,
            };
          },
        }),
        to = (t, e, i) => {
          let n = new Map(),
            r = { platform: tt, ...i },
            o = { ...r.platform, _c: n };
          return S(t, e, { ...r, platform: o });
        };
      var ts = i(6800),
        ta = i(5566);
      /*
       * React Tooltip
       * {@link https://github.com/ReactTooltip/react-tooltip}
       * @copyright ReactTooltip Team
       * @license MIT
       */ let tl = { core: !1, base: !1 };
      function tu({
        css: t,
        id: e = "react-tooltip-base-styles",
        type: i = "base",
        ref: n,
      }) {
        var r, o;
        if (
          !t ||
          "undefined" == typeof document ||
          tl[i] ||
          ("core" === i &&
            void 0 !== ta &&
            (null === (r = null == ta ? void 0 : ta.env) || void 0 === r
              ? void 0
              : r.REACT_TOOLTIP_DISABLE_CORE_STYLES)) ||
          ("base" !== i &&
            void 0 !== ta &&
            (null === (o = null == ta ? void 0 : ta.env) || void 0 === o
              ? void 0
              : o.REACT_TOOLTIP_DISABLE_BASE_STYLES))
        )
          return;
        "core" === i && (e = "react-tooltip-core-styles"), n || (n = {});
        let { insertAt: s } = n;
        if (document.getElementById(e))
          return void console.warn(
            `[react-tooltip] Element with id '${e}' already exists. Call \`removeStyle()\` first`
          );
        let a = document.head || document.getElementsByTagName("head")[0],
          l = document.createElement("style");
        (l.id = e),
          (l.type = "text/css"),
          "top" === s && a.firstChild
            ? a.insertBefore(l, a.firstChild)
            : a.appendChild(l),
          l.styleSheet
            ? (l.styleSheet.cssText = t)
            : l.appendChild(document.createTextNode(t)),
          (tl[i] = !0);
      }
      let tc = async ({
          elementReference: t = null,
          tooltipReference: e = null,
          tooltipArrowReference: i = null,
          place: n = "top",
          offset: r = 10,
          strategy: o = "absolute",
          middlewares: s = [
            te(Number(r)),
            tn({ fallbackAxisSideDirection: "start" }),
            ti({ padding: 5 }),
          ],
          border: a,
        }) =>
          t && null !== e
            ? i
              ? (s.push(tr({ element: i, padding: 5 })),
                to(t, e, { placement: n, strategy: o, middleware: s }).then(
                  ({ x: t, y: e, placement: i, middlewareData: n }) => {
                    var r, o;
                    let s = { left: `${t}px`, top: `${e}px`, border: a },
                      { x: l, y: u } =
                        null !== (r = n.arrow) && void 0 !== r
                          ? r
                          : { x: 0, y: 0 },
                      c =
                        null !==
                          (o = {
                            top: "bottom",
                            right: "left",
                            bottom: "top",
                            left: "right",
                          }[i.split("-")[0]]) && void 0 !== o
                          ? o
                          : "bottom",
                      h = 0;
                    if (a) {
                      let t = `${a}`.match(/(\d+)px/);
                      h = (null == t ? void 0 : t[1]) ? Number(t[1]) : 1;
                    }
                    return {
                      tooltipStyles: s,
                      tooltipArrowStyles: {
                        left: null != l ? `${l}px` : "",
                        top: null != u ? `${u}px` : "",
                        right: "",
                        bottom: "",
                        ...(a && { borderBottom: a, borderRight: a }),
                        [c]: `-${4 + h}px`,
                      },
                      place: i,
                    };
                  }
                ))
              : to(t, e, {
                  placement: "bottom",
                  strategy: o,
                  middleware: s,
                }).then(({ x: t, y: e, placement: i }) => ({
                  tooltipStyles: { left: `${t}px`, top: `${e}px` },
                  tooltipArrowStyles: {},
                  place: i,
                }))
            : { tooltipStyles: {}, tooltipArrowStyles: {}, place: n },
        th = (t, e) =>
          !("CSS" in window && "supports" in window.CSS) ||
          window.CSS.supports(t, e),
        td = (t, e, i) => {
          let n = null,
            r = function (...r) {
              let o = () => {
                (n = null), i || t.apply(this, r);
              };
              i && !n && (t.apply(this, r), (n = setTimeout(o, e))),
                i || (n && clearTimeout(n), (n = setTimeout(o, e)));
            };
          return (
            (r.cancel = () => {
              n && (clearTimeout(n), (n = null));
            }),
            r
          );
        },
        tp = (t) => null !== t && !Array.isArray(t) && "object" == typeof t,
        tf = (t, e) => {
          if (t === e) return !0;
          if (Array.isArray(t) && Array.isArray(e))
            return t.length === e.length && t.every((t, i) => tf(t, e[i]));
          if (Array.isArray(t) !== Array.isArray(e)) return !1;
          if (!tp(t) || !tp(e)) return t === e;
          let i = Object.keys(t),
            n = Object.keys(e);
          return i.length === n.length && i.every((i) => tf(t[i], e[i]));
        },
        tm = (t) => {
          if (!(t instanceof HTMLElement || t instanceof SVGElement)) return !1;
          let e = getComputedStyle(t);
          return ["overflow", "overflow-x", "overflow-y"].some((t) => {
            let i = e.getPropertyValue(t);
            return "auto" === i || "scroll" === i;
          });
        },
        tv = (t) => {
          if (!t) return null;
          let e = t.parentElement;
          for (; e; ) {
            if (tm(e)) return e;
            e = e.parentElement;
          }
          return document.scrollingElement || document.documentElement;
        },
        ty = "undefined" != typeof window ? n.useLayoutEffect : n.useEffect,
        tg = {
          anchorRefs: new Set(),
          activeAnchor: { current: null },
          attach: () => {},
          detach: () => {},
          setActiveAnchor: () => {},
        },
        tx = (0, n.createContext)({ getTooltipData: () => tg });
      function tw(t = "DEFAULT_TOOLTIP_ID") {
        return (0, n.useContext)(tx).getTooltipData(t);
      }
      var tb = {
          tooltip: "core-styles-module_tooltip__3vRRp",
          fixed: "core-styles-module_fixed__pcSol",
          arrow: "core-styles-module_arrow__cvMwQ",
          noArrow: "core-styles-module_noArrow__xock6",
          clickable: "core-styles-module_clickable__ZuTTB",
          show: "core-styles-module_show__Nt9eE",
          closing: "core-styles-module_closing__sGnxF",
        },
        tS = {
          tooltip: "styles-module_tooltip__mnnfp",
          arrow: "styles-module_arrow__K0L3T",
          dark: "styles-module_dark__xNqje",
          light: "styles-module_light__Z6W-X",
          success: "styles-module_success__A2AKt",
          warning: "styles-module_warning__SCK0X",
          error: "styles-module_error__JvumD",
          info: "styles-module_info__BWdHW",
        };
      let tP = ({
          forwardRef: t,
          id: e,
          className: i,
          classNameArrow: s,
          variant: l = "dark",
          anchorId: u,
          anchorSelect: c,
          place: h = "top",
          offset: d = 10,
          events: p = ["hover"],
          openOnClick: f = !1,
          positionStrategy: m = "absolute",
          middlewares: v,
          wrapper: y,
          delayShow: g = 0,
          delayHide: x = 0,
          float: w = !1,
          hidden: b = !1,
          noArrow: S = !1,
          clickable: P = !1,
          closeOnEsc: T = !1,
          closeOnScroll: A = !1,
          closeOnResize: E = !1,
          openEvents: R,
          closeEvents: k,
          globalCloseEvents: V,
          imperativeModeOnly: O,
          style: D,
          position: M,
          afterShow: j,
          afterHide: _,
          content: L,
          contentWrapperRef: F,
          isOpen: B,
          defaultIsOpen: $ = !1,
          setIsOpen: N,
          activeAnchor: z,
          setActiveAnchor: U,
          border: X,
          opacity: K,
          arrowColor: Y,
          role: q = "tooltip",
        }) => {
          var Z;
          let G = (0, n.useRef)(null),
            J = (0, n.useRef)(null),
            Q = (0, n.useRef)(null),
            tt = (0, n.useRef)(null),
            te = (0, n.useRef)(null),
            [ti, tn] = (0, n.useState)({
              tooltipStyles: {},
              tooltipArrowStyles: {},
              place: h,
            }),
            [tr, to] = (0, n.useState)(!1),
            [ta, tl] = (0, n.useState)(!1),
            [tu, th] = (0, n.useState)(null),
            tp = (0, n.useRef)(!1),
            tm = (0, n.useRef)(null),
            { anchorRefs: tg, setActiveAnchor: tx } = tw(e),
            tP = (0, n.useRef)(!1),
            [tT, tA] = (0, n.useState)([]),
            tE = (0, n.useRef)(!1),
            tC = f || p.includes("click"),
            tR =
              tC ||
              (null == R ? void 0 : R.click) ||
              (null == R ? void 0 : R.dblclick) ||
              (null == R ? void 0 : R.mousedown),
            tk = R
              ? { ...R }
              : {
                  mouseenter: !0,
                  focus: !0,
                  click: !1,
                  dblclick: !1,
                  mousedown: !1,
                };
          !R &&
            tC &&
            Object.assign(tk, { mouseenter: !1, focus: !1, click: !0 });
          let tV = k
            ? { ...k }
            : {
                mouseleave: !0,
                blur: !0,
                click: !1,
                dblclick: !1,
                mouseup: !1,
              };
          !k && tC && Object.assign(tV, { mouseleave: !1, blur: !1 });
          let tO = V
            ? { ...V }
            : {
                escape: T || !1,
                scroll: A || !1,
                resize: E || !1,
                clickOutsideAnchor: tR || !1,
              };
          O &&
            (Object.assign(tk, {
              mouseenter: !1,
              focus: !1,
              click: !1,
              dblclick: !1,
              mousedown: !1,
            }),
            Object.assign(tV, {
              mouseleave: !1,
              blur: !1,
              click: !1,
              dblclick: !1,
              mouseup: !1,
            }),
            Object.assign(tO, {
              escape: !1,
              scroll: !1,
              resize: !1,
              clickOutsideAnchor: !1,
            })),
            ty(
              () => (
                (tE.current = !0),
                () => {
                  tE.current = !1;
                }
              ),
              []
            );
          let tD = (t) => {
            tE.current &&
              (t && tl(!0),
              setTimeout(() => {
                tE.current && (null == N || N(t), void 0 === B && to(t));
              }, 10));
          };
          (0, n.useEffect)(() => {
            if (void 0 === B) return () => null;
            B && tl(!0);
            let t = setTimeout(() => {
              to(B);
            }, 10);
            return () => {
              clearTimeout(t);
            };
          }, [B]),
            (0, n.useEffect)(() => {
              if (tr !== tp.current) {
                if (
                  (te.current && clearTimeout(te.current),
                  (tp.current = tr),
                  tr)
                )
                  null == j || j();
                else {
                  let t = ((t) => {
                    let e = t.match(/^([\d.]+)(ms|s)$/);
                    if (!e) return 0;
                    let [, i, n] = e;
                    return Number(i) * ("ms" === n ? 1 : 1e3);
                  })(
                    getComputedStyle(document.body).getPropertyValue(
                      "--rt-transition-show-delay"
                    )
                  );
                  te.current = setTimeout(() => {
                    tl(!1), th(null), null == _ || _();
                  }, t + 25);
                }
              }
            }, [tr]);
          let tM = (t) => {
              tn((e) => (tf(e, t) ? e : t));
            },
            tj = (t = g) => {
              Q.current && clearTimeout(Q.current),
                ta
                  ? tD(!0)
                  : (Q.current = setTimeout(() => {
                      tD(!0);
                    }, t));
            },
            t_ = (t = x) => {
              tt.current && clearTimeout(tt.current),
                (tt.current = setTimeout(() => {
                  tP.current || tD(!1);
                }, t));
            },
            tL = (t) => {
              var e;
              if (!t) return;
              let i =
                null !== (e = t.currentTarget) && void 0 !== e ? e : t.target;
              if (!(null == i ? void 0 : i.isConnected))
                return U(null), void tx({ current: null });
              g ? tj() : tD(!0),
                U(i),
                tx({ current: i }),
                tt.current && clearTimeout(tt.current);
            },
            tF = () => {
              P ? t_(x || 100) : x ? t_() : tD(!1),
                Q.current && clearTimeout(Q.current);
            },
            tB = ({ x: t, y: e }) => {
              var i;
              tc({
                place:
                  null !== (i = null == tu ? void 0 : tu.place) && void 0 !== i
                    ? i
                    : h,
                offset: d,
                elementReference: {
                  getBoundingClientRect: () => ({
                    x: t,
                    y: e,
                    width: 0,
                    height: 0,
                    top: e,
                    left: t,
                    right: t,
                    bottom: e,
                  }),
                },
                tooltipReference: G.current,
                tooltipArrowReference: J.current,
                strategy: m,
                middlewares: v,
                border: X,
              }).then((t) => {
                tM(t);
              });
            },
            tI = (t) => {
              if (!t) return;
              let e = { x: t.clientX, y: t.clientY };
              tB(e), (tm.current = e);
            },
            t$ = (t) => {
              var e;
              if (!tr) return;
              let i = t.target;
              i.isConnected &&
                (null === (e = G.current) || void 0 === e || !e.contains(i)) &&
                ([document.querySelector(`[id='${u}']`), ...tT].some((t) =>
                  null == t ? void 0 : t.contains(i)
                ) ||
                  (tD(!1), Q.current && clearTimeout(Q.current)));
            },
            tW = td(tL, 50, !0),
            tN = td(tF, 50, !0),
            tz = (t) => {
              tN.cancel(), tW(t);
            },
            tU = () => {
              tW.cancel(), tN();
            },
            tH = (0, n.useCallback)(() => {
              var t, e;
              let i =
                null !== (t = null == tu ? void 0 : tu.position) && void 0 !== t
                  ? t
                  : M;
              i
                ? tB(i)
                : w
                ? tm.current && tB(tm.current)
                : (null == z ? void 0 : z.isConnected) &&
                  tc({
                    place:
                      null !== (e = null == tu ? void 0 : tu.place) &&
                      void 0 !== e
                        ? e
                        : h,
                    offset: d,
                    elementReference: z,
                    tooltipReference: G.current,
                    tooltipArrowReference: J.current,
                    strategy: m,
                    middlewares: v,
                    border: X,
                  }).then((t) => {
                    tE.current && tM(t);
                  });
            }, [
              tr,
              z,
              L,
              D,
              h,
              null == tu ? void 0 : tu.place,
              d,
              m,
              M,
              null == tu ? void 0 : tu.position,
              w,
            ]);
          (0, n.useEffect)(() => {
            var t, e;
            let i = new Set(tg);
            tT.forEach((t) => {
              i.add({ current: t });
            });
            let n = document.querySelector(`[id='${u}']`);
            n && i.add({ current: n });
            let s = () => {
                tD(!1);
              },
              l = tv(z),
              c = tv(G.current);
            tO.scroll &&
              (window.addEventListener("scroll", s),
              null == l || l.addEventListener("scroll", s),
              null == c || c.addEventListener("scroll", s));
            let h = null;
            tO.resize
              ? window.addEventListener("resize", s)
              : z &&
                G.current &&
                (h = (function (t, e, i, n) {
                  let s;
                  void 0 === n && (n = {});
                  let {
                      ancestorScroll: l = !0,
                      ancestorResize: u = !0,
                      elementResize: c = "function" == typeof ResizeObserver,
                      layoutShift: h = "function" ==
                        typeof IntersectionObserver,
                      animationFrame: d = !1,
                    } = n,
                    p = W(t),
                    f = l || u ? [...(p ? I(p) : []), ...I(e)] : [];
                  f.forEach((t) => {
                    l && t.addEventListener("scroll", i, { passive: !0 }),
                      u && t.addEventListener("resize", i);
                  });
                  let m =
                      p && h
                        ? (function (t, e) {
                            let i,
                              n = null,
                              s = C(t);
                            function l() {
                              var t;
                              clearTimeout(i),
                                null == (t = n) || t.disconnect(),
                                (n = null);
                            }
                            return (
                              (function u(c, h) {
                                void 0 === c && (c = !1),
                                  void 0 === h && (h = 1),
                                  l();
                                let {
                                  left: d,
                                  top: p,
                                  width: f,
                                  height: m,
                                } = t.getBoundingClientRect();
                                if ((c || e(), !f || !m)) return;
                                let v = a(p),
                                  y = a(s.clientWidth - (d + f)),
                                  g = {
                                    rootMargin:
                                      -v +
                                      "px " +
                                      -y +
                                      "px " +
                                      -a(s.clientHeight - (p + m)) +
                                      "px " +
                                      -a(d) +
                                      "px",
                                    threshold: o(0, r(1, h)) || 1,
                                  },
                                  x = !0;
                                function w(t) {
                                  let e = t[0].intersectionRatio;
                                  if (e !== h) {
                                    if (!x) return u();
                                    e
                                      ? u(!1, e)
                                      : (i = setTimeout(() => {
                                          u(!1, 1e-7);
                                        }, 1e3));
                                  }
                                  x = !1;
                                }
                                try {
                                  n = new IntersectionObserver(w, {
                                    ...g,
                                    root: s.ownerDocument,
                                  });
                                } catch (t) {
                                  n = new IntersectionObserver(w, g);
                                }
                                n.observe(t);
                              })(!0),
                              l
                            );
                          })(p, i)
                        : null,
                    v = -1,
                    y = null;
                  c &&
                    ((y = new ResizeObserver((t) => {
                      let [n] = t;
                      n &&
                        n.target === p &&
                        y &&
                        (y.unobserve(e),
                        cancelAnimationFrame(v),
                        (v = requestAnimationFrame(() => {
                          var t;
                          null == (t = y) || t.observe(e);
                        }))),
                        i();
                    })),
                    p && !d && y.observe(p),
                    y.observe(e));
                  let g = d ? H(t) : null;
                  return (
                    d &&
                      (function e() {
                        let n = H(t);
                        g &&
                          (n.x !== g.x ||
                            n.y !== g.y ||
                            n.width !== g.width ||
                            n.height !== g.height) &&
                          i(),
                          (g = n),
                          (s = requestAnimationFrame(e));
                      })(),
                    i(),
                    () => {
                      var t;
                      f.forEach((t) => {
                        l && t.removeEventListener("scroll", i),
                          u && t.removeEventListener("resize", i);
                      }),
                        null == m || m(),
                        null == (t = y) || t.disconnect(),
                        (y = null),
                        d && cancelAnimationFrame(s);
                    }
                  );
                })(z, G.current, tH, {
                  ancestorResize: !0,
                  elementResize: !0,
                  layoutShift: !0,
                }));
            let d = (t) => {
              "Escape" === t.key && tD(!1);
            };
            tO.escape && window.addEventListener("keydown", d),
              tO.clickOutsideAnchor && window.addEventListener("click", t$);
            let p = [],
              f = (t) => {
                (tr && (null == t ? void 0 : t.target) === z) || tL(t);
              },
              m = (t) => {
                tr && (null == t ? void 0 : t.target) === z && tF();
              },
              v = ["mouseenter", "mouseleave", "focus", "blur"],
              y = ["click", "dblclick", "mousedown", "mouseup"];
            Object.entries(tk).forEach(([t, e]) => {
              e &&
                (v.includes(t)
                  ? p.push({ event: t, listener: tz })
                  : y.includes(t) && p.push({ event: t, listener: f }));
            }),
              Object.entries(tV).forEach(([t, e]) => {
                e &&
                  (v.includes(t)
                    ? p.push({ event: t, listener: tU })
                    : y.includes(t) && p.push({ event: t, listener: m }));
              }),
              w && p.push({ event: "pointermove", listener: tI });
            let g = () => {
                tP.current = !0;
              },
              x = () => {
                (tP.current = !1), tF();
              };
            return (
              P &&
                !tR &&
                (null === (t = G.current) ||
                  void 0 === t ||
                  t.addEventListener("mouseenter", g),
                null === (e = G.current) ||
                  void 0 === e ||
                  e.addEventListener("mouseleave", x)),
              p.forEach(({ event: t, listener: e }) => {
                i.forEach((i) => {
                  var n;
                  null === (n = i.current) ||
                    void 0 === n ||
                    n.addEventListener(t, e);
                });
              }),
              () => {
                var t, e;
                tO.scroll &&
                  (window.removeEventListener("scroll", s),
                  null == l || l.removeEventListener("scroll", s),
                  null == c || c.removeEventListener("scroll", s)),
                  tO.resize
                    ? window.removeEventListener("resize", s)
                    : null == h || h(),
                  tO.clickOutsideAnchor &&
                    window.removeEventListener("click", t$),
                  tO.escape && window.removeEventListener("keydown", d),
                  P &&
                    !tR &&
                    (null === (t = G.current) ||
                      void 0 === t ||
                      t.removeEventListener("mouseenter", g),
                    null === (e = G.current) ||
                      void 0 === e ||
                      e.removeEventListener("mouseleave", x)),
                  p.forEach(({ event: t, listener: e }) => {
                    i.forEach((i) => {
                      var n;
                      null === (n = i.current) ||
                        void 0 === n ||
                        n.removeEventListener(t, e);
                    });
                  });
              }
            );
          }, [z, tH, ta, tg, tT, R, k, V, tC, g, x]),
            (0, n.useEffect)(() => {
              var t, i;
              let n =
                null !==
                  (i =
                    null !== (t = null == tu ? void 0 : tu.anchorSelect) &&
                    void 0 !== t
                      ? t
                      : c) && void 0 !== i
                  ? i
                  : "";
              !n && e && (n = `[data-tooltip-id='${e.replace(/'/g, "\\'")}']`);
              let r = new MutationObserver((t) => {
                let i = [],
                  r = [];
                t.forEach((t) => {
                  if (
                    ("attributes" === t.type &&
                      "data-tooltip-id" === t.attributeName &&
                      (t.target.getAttribute("data-tooltip-id") === e
                        ? i.push(t.target)
                        : t.oldValue === e && r.push(t.target)),
                    "childList" === t.type)
                  ) {
                    if (z) {
                      let e = [...t.removedNodes].filter(
                        (t) => 1 === t.nodeType
                      );
                      if (n)
                        try {
                          r.push(...e.filter((t) => t.matches(n))),
                            r.push(
                              ...e.flatMap((t) => [...t.querySelectorAll(n)])
                            );
                        } catch (t) {}
                      e.some((t) => {
                        var e;
                        return (
                          !!(null === (e = null == t ? void 0 : t.contains) ||
                          void 0 === e
                            ? void 0
                            : e.call(t, z)) &&
                          (tl(!1),
                          tD(!1),
                          U(null),
                          Q.current && clearTimeout(Q.current),
                          tt.current && clearTimeout(tt.current),
                          !0)
                        );
                      });
                    }
                    if (n)
                      try {
                        let e = [...t.addedNodes].filter(
                          (t) => 1 === t.nodeType
                        );
                        i.push(...e.filter((t) => t.matches(n))),
                          i.push(
                            ...e.flatMap((t) => [...t.querySelectorAll(n)])
                          );
                      } catch (t) {}
                  }
                }),
                  (i.length || r.length) &&
                    tA((t) => [...t.filter((t) => !r.includes(t)), ...i]);
              });
              return (
                r.observe(document.body, {
                  childList: !0,
                  subtree: !0,
                  attributes: !0,
                  attributeFilter: ["data-tooltip-id"],
                  attributeOldValue: !0,
                }),
                () => {
                  r.disconnect();
                }
              );
            }, [e, c, null == tu ? void 0 : tu.anchorSelect, z]),
            (0, n.useEffect)(() => {
              tH();
            }, [tH]),
            (0, n.useEffect)(() => {
              if (!(null == F ? void 0 : F.current)) return () => null;
              let t = new ResizeObserver(() => {
                setTimeout(() => tH());
              });
              return (
                t.observe(F.current),
                () => {
                  t.disconnect();
                }
              );
            }, [L, null == F ? void 0 : F.current]),
            (0, n.useEffect)(() => {
              var t;
              let e = document.querySelector(`[id='${u}']`),
                i = [...tT, e];
              (z && i.includes(z)) ||
                U(null !== (t = tT[0]) && void 0 !== t ? t : e);
            }, [u, tT, z]),
            (0, n.useEffect)(
              () => (
                $ && tD(!0),
                () => {
                  Q.current && clearTimeout(Q.current),
                    tt.current && clearTimeout(tt.current);
                }
              ),
              []
            ),
            (0, n.useEffect)(() => {
              var t;
              let i =
                null !== (t = null == tu ? void 0 : tu.anchorSelect) &&
                void 0 !== t
                  ? t
                  : c;
              if (
                (!i &&
                  e &&
                  (i = `[data-tooltip-id='${e.replace(/'/g, "\\'")}']`),
                i)
              )
                try {
                  let t = Array.from(document.querySelectorAll(i));
                  tA(t);
                } catch (t) {
                  tA([]);
                }
            }, [e, c, null == tu ? void 0 : tu.anchorSelect]),
            (0, n.useEffect)(() => {
              Q.current && (clearTimeout(Q.current), tj(g));
            }, [g]);
          let tX =
              null !== (Z = null == tu ? void 0 : tu.content) && void 0 !== Z
                ? Z
                : L,
            tK = tr && Object.keys(ti.tooltipStyles).length > 0;
          return (
            (0, n.useImperativeHandle)(t, () => ({
              open: (t) => {
                if (null == t ? void 0 : t.anchorSelect)
                  try {
                    document.querySelector(t.anchorSelect);
                  } catch (e) {
                    return void console.warn(
                      `[react-tooltip] "${t.anchorSelect}" is not a valid CSS selector`
                    );
                  }
                th(null != t ? t : null),
                  (null == t ? void 0 : t.delay) ? tj(t.delay) : tD(!0);
              },
              close: (t) => {
                (null == t ? void 0 : t.delay) ? t_(t.delay) : tD(!1);
              },
              activeAnchor: z,
              place: ti.place,
              isOpen: !!(ta && !b && tX && tK),
            })),
            ta && !b && tX
              ? n.createElement(
                  y,
                  {
                    id: e,
                    role: q,
                    className: ts(
                      "react-tooltip",
                      tb.tooltip,
                      tS.tooltip,
                      tS[l],
                      i,
                      `react-tooltip__place-${ti.place}`,
                      tb[tK ? "show" : "closing"],
                      tK ? "react-tooltip__show" : "react-tooltip__closing",
                      "fixed" === m && tb.fixed,
                      P && tb.clickable
                    ),
                    onTransitionEnd: (t) => {
                      te.current && clearTimeout(te.current),
                        tr ||
                          "opacity" !== t.propertyName ||
                          (tl(!1), th(null), null == _ || _());
                    },
                    style: {
                      ...D,
                      ...ti.tooltipStyles,
                      opacity: void 0 !== K && tK ? K : void 0,
                    },
                    ref: G,
                  },
                  tX,
                  n.createElement(y, {
                    className: ts(
                      "react-tooltip-arrow",
                      tb.arrow,
                      tS.arrow,
                      s,
                      S && tb.noArrow
                    ),
                    style: {
                      ...ti.tooltipArrowStyles,
                      background: Y
                        ? `linear-gradient(to right bottom, transparent 50%, ${Y} 50%)`
                        : void 0,
                    },
                    ref: J,
                  })
                )
              : null
          );
        },
        tT = ({ content: t }) =>
          n.createElement("span", { dangerouslySetInnerHTML: { __html: t } }),
        tA = n.forwardRef(
          (
            {
              id: t,
              anchorId: e,
              anchorSelect: i,
              content: r,
              html: o,
              render: s,
              className: a,
              classNameArrow: l,
              variant: u = "dark",
              place: c = "top",
              offset: h = 10,
              wrapper: d = "div",
              children: p = null,
              events: f = ["hover"],
              openOnClick: m = !1,
              positionStrategy: v = "absolute",
              middlewares: y,
              delayShow: g = 0,
              delayHide: x = 0,
              float: w = !1,
              hidden: b = !1,
              noArrow: S = !1,
              clickable: P = !1,
              closeOnEsc: T = !1,
              closeOnScroll: A = !1,
              closeOnResize: E = !1,
              openEvents: C,
              closeEvents: R,
              globalCloseEvents: k,
              imperativeModeOnly: V = !1,
              style: O,
              position: D,
              isOpen: M,
              defaultIsOpen: j = !1,
              disableStyleInjection: _ = !1,
              border: L,
              opacity: F,
              arrowColor: B,
              setIsOpen: I,
              afterShow: $,
              afterHide: W,
              role: N = "tooltip",
            },
            z
          ) => {
            let [U, H] = (0, n.useState)(r),
              [X, K] = (0, n.useState)(o),
              [Y, q] = (0, n.useState)(c),
              [Z, G] = (0, n.useState)(u),
              [J, Q] = (0, n.useState)(h),
              [tt, te] = (0, n.useState)(g),
              [ti, tn] = (0, n.useState)(x),
              [tr, to] = (0, n.useState)(w),
              [ta, tl] = (0, n.useState)(b),
              [tu, tc] = (0, n.useState)(d),
              [td, tp] = (0, n.useState)(f),
              [tf, tm] = (0, n.useState)(v),
              [tv, ty] = (0, n.useState)(null),
              [tg, tx] = (0, n.useState)(null),
              tb = (0, n.useRef)(_),
              { anchorRefs: tS, activeAnchor: tA } = tw(t),
              tE = (t) =>
                null == t
                  ? void 0
                  : t.getAttributeNames().reduce((e, i) => {
                      var n;
                      return (
                        i.startsWith("data-tooltip-") &&
                          (e[i.replace(/^data-tooltip-/, "")] =
                            null !==
                              (n = null == t ? void 0 : t.getAttribute(i)) &&
                            void 0 !== n
                              ? n
                              : null),
                        e
                      );
                    }, {}),
              tC = (t) => {
                let e = {
                  place: (t) => {
                    q(null != t ? t : c);
                  },
                  content: (t) => {
                    H(null != t ? t : r);
                  },
                  html: (t) => {
                    K(null != t ? t : o);
                  },
                  variant: (t) => {
                    G(null != t ? t : u);
                  },
                  offset: (t) => {
                    Q(null === t ? h : Number(t));
                  },
                  wrapper: (t) => {
                    tc(null != t ? t : d);
                  },
                  events: (t) => {
                    let e = null == t ? void 0 : t.split(" ");
                    tp(null != e ? e : f);
                  },
                  "position-strategy": (t) => {
                    tm(null != t ? t : v);
                  },
                  "delay-show": (t) => {
                    te(null === t ? g : Number(t));
                  },
                  "delay-hide": (t) => {
                    tn(null === t ? x : Number(t));
                  },
                  float: (t) => {
                    to(null === t ? w : "true" === t);
                  },
                  hidden: (t) => {
                    tl(null === t ? b : "true" === t);
                  },
                  "class-name": (t) => {
                    ty(t);
                  },
                };
                Object.values(e).forEach((t) => t(null)),
                  Object.entries(t).forEach(([t, i]) => {
                    var n;
                    null === (n = e[t]) || void 0 === n || n.call(e, i);
                  });
              };
            (0, n.useEffect)(() => {
              H(r);
            }, [r]),
              (0, n.useEffect)(() => {
                K(o);
              }, [o]),
              (0, n.useEffect)(() => {
                q(c);
              }, [c]),
              (0, n.useEffect)(() => {
                G(u);
              }, [u]),
              (0, n.useEffect)(() => {
                Q(h);
              }, [h]),
              (0, n.useEffect)(() => {
                te(g);
              }, [g]),
              (0, n.useEffect)(() => {
                tn(x);
              }, [x]),
              (0, n.useEffect)(() => {
                to(w);
              }, [w]),
              (0, n.useEffect)(() => {
                tl(b);
              }, [b]),
              (0, n.useEffect)(() => {
                tm(v);
              }, [v]),
              (0, n.useEffect)(() => {
                tb.current !== _ &&
                  console.warn(
                    "[react-tooltip] Do not change `disableStyleInjection` dynamically."
                  );
              }, [_]),
              (0, n.useEffect)(() => {
                "undefined" != typeof window &&
                  window.dispatchEvent(
                    new CustomEvent("react-tooltip-inject-styles", {
                      detail: { disableCore: "core" === _, disableBase: _ },
                    })
                  );
              }, []),
              (0, n.useEffect)(() => {
                var n;
                let r = new Set(tS),
                  o = i;
                if (
                  (!o &&
                    t &&
                    (o = `[data-tooltip-id='${t.replace(/'/g, "\\'")}']`),
                  o)
                )
                  try {
                    document.querySelectorAll(o).forEach((t) => {
                      r.add({ current: t });
                    });
                  } catch (t) {
                    console.warn(
                      `[react-tooltip] "${o}" is not a valid CSS selector`
                    );
                  }
                let s = document.querySelector(`[id='${e}']`);
                if ((s && r.add({ current: s }), !r.size)) return () => null;
                let a =
                    null !== (n = null != tg ? tg : s) && void 0 !== n
                      ? n
                      : tA.current,
                  l = new MutationObserver((t) => {
                    t.forEach((t) => {
                      var e;
                      a &&
                        "attributes" === t.type &&
                        (null === (e = t.attributeName) || void 0 === e
                          ? void 0
                          : e.startsWith("data-tooltip-")) &&
                        tC(tE(a));
                    });
                  });
                return (
                  a &&
                    (tC(tE(a)),
                    l.observe(a, {
                      attributes: !0,
                      childList: !1,
                      subtree: !1,
                    })),
                  () => {
                    l.disconnect();
                  }
                );
              }, [tS, tA, tg, e, i]),
              (0, n.useEffect)(() => {
                (null == O ? void 0 : O.border) &&
                  console.warn(
                    "[react-tooltip] Do not set `style.border`. Use `border` prop instead."
                  ),
                  L &&
                    !th("border", `${L}`) &&
                    console.warn(
                      `[react-tooltip] "${L}" is not a valid \`border\`.`
                    ),
                  (null == O ? void 0 : O.opacity) &&
                    console.warn(
                      "[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."
                    ),
                  F &&
                    !th("opacity", `${F}`) &&
                    console.warn(
                      `[react-tooltip] "${F}" is not a valid \`opacity\`.`
                    );
              }, []);
            let tR = p,
              tk = (0, n.useRef)(null);
            if (s) {
              let t = s({
                content:
                  (null == tg
                    ? void 0
                    : tg.getAttribute("data-tooltip-content")) ||
                  U ||
                  null,
                activeAnchor: tg,
              });
              tR = t
                ? n.createElement(
                    "div",
                    { ref: tk, className: "react-tooltip-content-wrapper" },
                    t
                  )
                : null;
            } else U && (tR = U);
            X && (tR = n.createElement(tT, { content: X }));
            let tV = {
              forwardRef: z,
              id: t,
              anchorId: e,
              anchorSelect: i,
              className: ts(a, tv),
              classNameArrow: l,
              content: tR,
              contentWrapperRef: tk,
              place: Y,
              variant: Z,
              offset: J,
              wrapper: tu,
              events: td,
              openOnClick: m,
              positionStrategy: tf,
              middlewares: y,
              delayShow: tt,
              delayHide: ti,
              float: tr,
              hidden: ta,
              noArrow: S,
              clickable: P,
              closeOnEsc: T,
              closeOnScroll: A,
              closeOnResize: E,
              openEvents: C,
              closeEvents: R,
              globalCloseEvents: k,
              imperativeModeOnly: V,
              style: O,
              position: D,
              isOpen: M,
              defaultIsOpen: j,
              border: L,
              opacity: F,
              arrowColor: B,
              setIsOpen: I,
              afterShow: $,
              afterHide: W,
              activeAnchor: tg,
              setActiveAnchor: (t) => tx(t),
              role: N,
            };
            return n.createElement(tP, { ...tV });
          }
        );
      "undefined" != typeof window &&
        window.addEventListener("react-tooltip-inject-styles", (t) => {
          t.detail.disableCore ||
            tu({
              css: ":root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}",
              type: "core",
            }),
            t.detail.disableBase ||
              tu({
                css: `
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`,
                type: "base",
              });
        });
    },
  },
]);
